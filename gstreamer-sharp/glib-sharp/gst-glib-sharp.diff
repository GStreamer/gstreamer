--- glib-sharp-upstream/Argv.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Argv.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Argv.cs : Argv marshaling class
+// Gst.GLib.Argv.cs : Argv marshaling class
 //
 // Author: Mike Kestner  <mkestner@novell.com>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/Boxed.cs	2004-10-21 03:08:10.000000000 +0200
+++ glib-sharp/Boxed.cs	2009-10-03 11:59:51.000000000 +0200
@@ -18,7 +18,7 @@
 // Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 // Boston, MA 02111-1307, USA.
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/CDeclCallbackAttribute.cs	2009-07-02 22:18:10.000000000 +0200
+++ glib-sharp/CDeclCallbackAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/ClassInitializerAttribute.cs	2007-09-07 16:40:46.000000000 +0200
+++ glib-sharp/ClassInitializerAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/ConnectBeforeAttribute.cs	2004-06-25 20:42:19.000000000 +0200
+++ glib-sharp/ConnectBeforeAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/DefaultSignalHandlerAttribute.cs	2004-06-25 20:42:19.000000000 +0200
+++ glib-sharp/DefaultSignalHandlerAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/DelegateWrapper.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/DelegateWrapper.cs	2009-10-03 11:59:51.000000000 +0200
@@ -22,7 +22,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -56,8 +56,8 @@
 				// currently only GObjects store
 				// callbacks over the long-term
 
-				if (o is GLib.Object) {
-					AddDestroyNotify ((GLib.Object) o);
+				if (o is Gst.GLib.Object) {
+					AddDestroyNotify ((Gst.GLib.Object) o);
 				}
 			} else {
 				// If o is null, we cannot ask for a destroy
@@ -75,7 +75,7 @@
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
 		private static extern void g_object_set_data_full (IntPtr obj, IntPtr name, IntPtr data, DestroyNotify destroy);
 		
-		private void AddDestroyNotify (GLib.Object o) {
+		private void AddDestroyNotify (Gst.GLib.Object o) {
 			// This is a bit of an ugly hack. There is no
 			// way of getting a destroy notification
 			// explicitly, so we set some data and ask
@@ -92,7 +92,7 @@
 			}
 		}
 
-		// This callback is invoked by GLib to indicate that the
+		// This callback is invoked by Gst.GLib to indicate that the
 		// object that owned the native delegate wrapper no longer
 		// exists and the instance of the delegate itself is removed from the hash table.
 		private void OnDestroy (IntPtr data) {
--- glib-sharp-upstream/DestroyNotify.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/DestroyNotify.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.DestroyNotify.cs - internal DestroyNotify helper
+// Gst.GLib.DestroyNotify.cs - internal DestroyNotify helper
 //
 // Author: Mike Kestner <mkestner@novell.com>
 //
@@ -18,7 +18,7 @@
 // Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 // Boston, MA 02111-1307, USA.
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/EnumWrapper.cs	2005-07-22 20:36:50.000000000 +0200
+++ glib-sharp/EnumWrapper.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,12 +19,12 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
 	
-	[Obsolete ("Replaced by direct enum type casts to/from GLib.Value")]
+	[Obsolete ("Replaced by direct enum type casts to/from Gst.GLib.Value")]
 	public class EnumWrapper {
 		int val;
 		public bool flags;
--- glib-sharp-upstream/ExceptionManager.cs	2007-03-08 21:28:24.000000000 +0100
+++ glib-sharp/ExceptionManager.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Application.cs - static Application class
+// Gst.GLib.Application.cs - static Application class
 //
 // Authors: Mike Kestner <mkestner@novell.com>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
@@ -53,7 +53,7 @@
 		{
 			if (UnhandledException == null) {
 				Console.Error.WriteLine ("Exception in Gtk# callback delegate");
-				Console.Error.WriteLine ("  Note: Applications can use GLib.ExceptionManager.UnhandledException to handle the exception.");
+				Console.Error.WriteLine ("  Note: Applications can use Gst.GLib.ExceptionManager.UnhandledException to handle the exception.");
 				Console.Error.WriteLine (e);
 				Console.Error.WriteLine (new System.Diagnostics.StackTrace (true));
 				Environment.Exit (1);
--- glib-sharp-upstream/FileUtils.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/FileUtils.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.FileUtils.cs - GFileUtils class implementation
+// Gst.GLib.FileUtils.cs - GFileUtils class implementation
 //
 // Author: Martin Baulig <martin@gnome.org>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Text;
--- glib-sharp-upstream/Format.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Format.cs	2009-10-03 11:59:51.000000000 +0200
@@ -23,7 +23,7 @@
 using System;
 using System.Runtime.InteropServices;
 
-namespace GLib {
+namespace Gst.GLib {
 #if GTK_SHARP_2_14
 	public class Format {
 		[DllImport ("libglib-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
--- glib-sharp-upstream/GException.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/GException.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/GInterfaceAdapter.cs	2009-07-21 08:51:10.000000000 +0200
+++ glib-sharp/GInterfaceAdapter.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/GInterfaceAttribute.cs	2007-09-11 22:34:24.000000000 +0200
+++ glib-sharp/GInterfaceAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -17,7 +17,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/Global.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Global.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Global.cs - Global glib properties and methods.
+// Gst.GLib.Global.cs - Global glib properties and methods.
 //
 // Author: Andres G. Aragoneses <aaragoneses@novell.com>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Text;
@@ -33,12 +33,12 @@
 
 		public static string ProgramName {
 			get {
-				return GLib.Marshaller.PtrToStringGFree(g_get_prgname());
+				return Gst.GLib.Marshaller.PtrToStringGFree(g_get_prgname());
 			}
 			set { 
-				IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (value);
+				IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (value);
 				g_set_prgname (native_name);
-				GLib.Marshaller.Free (native_name);
+				Gst.GLib.Marshaller.Free (native_name);
 			}
 		}
 
@@ -50,12 +50,12 @@
 
 		public static string ApplicationName {
 			get {
-				return GLib.Marshaller.PtrToStringGFree(g_get_application_name());	
+				return Gst.GLib.Marshaller.PtrToStringGFree(g_get_application_name());	
 			}
 			set {
-				IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (value);
+				IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (value);
 				g_set_application_name (native_name);
-				GLib.Marshaller.Free (native_name);				
+				Gst.GLib.Marshaller.Free (native_name);				
 			}
 		}
 
--- glib-sharp-upstream/GString.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/GString.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.GString.cs : Marshaler for GStrings 
+// Gst.GLib.GString.cs : Marshaler for GStrings 
 //
 // Author: Mike Kestner  <mkestner@ximian.com>
 //
@@ -19,11 +19,11 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 	using System;
 	using System.Runtime.InteropServices;
 	
-	public class GString : GLib.IWrapper {
+	public class GString : Gst.GLib.IWrapper {
 
 		IntPtr handle;
 
--- glib-sharp-upstream/GTypeAttribute.cs	2005-05-04 18:54:24.000000000 +0200
+++ glib-sharp/GTypeAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -17,7 +17,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/GType.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/GType.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Type.cs - GLib GType class implementation
+// Gst.GLib.Type.cs - Gst.GLib GType class implementation
 //
 // Author: Mike Kestner <mkestner@speakeasy.net>
 //
@@ -20,7 +20,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -29,7 +29,7 @@
 	using System.Runtime.InteropServices;
 	using System.Text;
 
-	public delegate System.Type TypeResolutionHandler (GLib.GType gtype, string gtype_name);
+	public delegate System.Type TypeResolutionHandler (Gst.GLib.GType gtype, string gtype_name);
 
 	[StructLayout(LayoutKind.Sequential)]
 	public struct GType {
@@ -103,8 +103,8 @@
 
 		static GType ()
 		{
-			if (!GLib.Thread.Supported)
-				GLib.Thread.Init ();
+			if (!Gst.GLib.Thread.Supported)
+				Gst.GLib.Thread.Init ();
 
 			g_type_init ();
 
@@ -119,7 +119,7 @@
 			Register (GType.Double, typeof (double));
 			Register (GType.String, typeof (string));
 			Register (GType.Pointer, typeof (IntPtr));
-			Register (GType.Object, typeof (GLib.Object));
+			Register (GType.Object, typeof (Gst.GLib.Object));
 			Register (GType.Pointer, typeof (IntPtr));
 
 			// One-way mapping
@@ -135,8 +135,8 @@
 					return (GType)gtypes[type];
 			}
 
-			if (type.IsSubclassOf (typeof (GLib.Object))) {
-				gtype = GLib.Object.LookupGType (type);
+			if (type.IsSubclassOf (typeof (Gst.GLib.Object))) {
+				gtype = Gst.GLib.Object.LookupGType (type);
 				Register (gtype, type);
 				return gtype;
 			}
@@ -148,7 +148,7 @@
 				GTypeAttribute gattr = (GTypeAttribute)Attribute.GetCustomAttribute (type, typeof (GTypeAttribute), false);
 				pi = gattr.WrapperType.GetProperty ("GType", BindingFlags.Public | BindingFlags.Static);
 				gtype = (GType) pi.GetValue (null, null);
-			} else if (type.IsSubclassOf (typeof (GLib.Opaque)))
+			} else if (type.IsSubclassOf (typeof (Gst.GLib.Opaque)))
 				gtype = GType.Pointer;
 			else
 				gtype = ManagedValue.GType;
@@ -162,7 +162,7 @@
 			for (int i = 1; i < cname.Length; i++) {
 				if (System.Char.IsUpper (cname[i])) {
 					if (i == 1 && cname [0] == 'G')
-						return "GLib." + cname.Substring (1);
+						return "Gst.GLib." + cname.Substring (1);
 					else
 						return cname.Substring (0, i) + "." + cname.Substring (i);
 				}
@@ -193,7 +193,7 @@
 			string native_name = Marshaller.Utf8PtrToString (g_type_name (typeid));
 
 			if (ResolveType != null) {
-				GLib.GType gt = new GLib.GType (typeid);
+				Gst.GLib.GType gt = new Gst.GLib.GType (typeid);
 
 				Delegate[] invocation_list = ResolveType.GetInvocationList ();
 				foreach (Delegate d in invocation_list) {
@@ -302,7 +302,7 @@
 		public GType GetThresholdType ()
 		{
 			GType curr_type = this;
-			while (curr_type.ToString ().StartsWith ("__gtksharp_"))
+			while (curr_type.ToString ().StartsWith ("__gst_gtksharp_"))
 				curr_type = curr_type.GetBaseType ();
 			return curr_type;
 		}
@@ -326,7 +326,7 @@
 			string qn = t.FullName;
 			// Just a random guess
 			StringBuilder sb = new StringBuilder (20 + qn.Length);
-			sb.Append ("__gtksharp_");
+			sb.Append ("__gst_gtksharp_");
 			sb.Append (type_uid++);
 			sb.Append ("_");
 			foreach (char c in qn) {
@@ -349,14 +349,14 @@
 		{
 			GType parent_gtype = LookupGObjectType (t.BaseType);
 			string name = BuildEscapedName (t);
-			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
+			IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (name);
 			GTypeQuery query;
 			g_type_query (parent_gtype.Val, out query);
 			GTypeInfo info = new GTypeInfo ();
 			info.class_size = (ushort) query.class_size;
 			info.instance_size = (ushort) query.instance_size;
 			GType gtype = new GType (g_type_register_static (parent_gtype.Val, native_name, ref info, 0));
-			GLib.Marshaller.Free (native_name);
+			Gst.GLib.Marshaller.Free (native_name);
 			Register (gtype, t);
 			return gtype;
 		}
@@ -372,7 +372,7 @@
 			if (pi != null)
 				return (GType) pi.GetValue (null, null);
 			
-			return GLib.Object.RegisterGType (t);
+			return Gst.GLib.Object.RegisterGType (t);
 		}
 
 		internal static IntPtr ValFromInstancePtr (IntPtr handle)
--- glib-sharp-upstream/Idle.cs	2009-09-22 04:52:41.000000000 +0200
+++ glib-sharp/Idle.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Idle.cs - Idle class implementation
+// Gst.GLib.Idle.cs - Idle class implementation
 //
 // Author(s):
 //	Mike Kestner <mkestner@speakeasy.net>
@@ -24,7 +24,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
--- glib-sharp-upstream/IgnoreClassInitializersAttribute.cs	2007-09-07 16:40:46.000000000 +0200
+++ glib-sharp/IgnoreClassInitializersAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/InitiallyUnowned.cs	2009-08-08 05:06:53.000000000 +0200
+++ glib-sharp/InitiallyUnowned.cs	2009-10-03 11:59:51.000000000 +0200
@@ -20,7 +20,7 @@
 
 #if GTK_SHARP_2_10
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -31,7 +31,7 @@
 
 		protected InitiallyUnowned (IntPtr raw) : base (raw) {}
 
-		public new static GLib.GType GType {
+		public new static Gst.GLib.GType GType {
 			get {
 				return GType.Object;
 			}
--- glib-sharp-upstream/IOChannel.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/IOChannel.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,11 +19,11 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLibSharp {
+namespace Gst.GLibSharp {
 
 	using System;
 	using System.Runtime.InteropServices;
-	using GLib;
+	using Gst.GLib;
 
 	[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
 	internal delegate bool IOFuncNative(IntPtr source, int condition, IntPtr data);
@@ -51,11 +51,11 @@
 	}
 }
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
-	using GLibSharp;
+	using Gst.GLibSharp;
 
 	public class IOChannel : IDisposable, IWrapper {
 
--- glib-sharp-upstream/IWrapper.cs	2004-06-25 20:42:19.000000000 +0200
+++ glib-sharp/IWrapper.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib
+namespace Gst.GLib
 {
 	using System;
 
--- glib-sharp-upstream/ListBase.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/ListBase.cs	2009-10-03 11:59:51.000000000 +0200
@@ -20,13 +20,13 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
 	using System.Runtime.InteropServices;
 
-	public abstract class ListBase : IDisposable, ICollection, GLib.IWrapper, ICloneable {
+	public abstract class ListBase : IDisposable, ICollection, Gst.GLib.IWrapper, ICloneable {
 
 		private IntPtr list_ptr = IntPtr.Zero;
 		private int length = -1;
@@ -159,10 +159,10 @@
 					ret = Marshaller.FilenamePtrToString (data);
 				else if (element_type == typeof (IntPtr))
 					ret = data;
-				else if (element_type.IsSubclassOf (typeof (GLib.Object)))
-					ret = GLib.Object.GetObject (data, false);
-				else if (element_type.IsSubclassOf (typeof (GLib.Opaque)))
-					ret = GLib.Opaque.GetOpaque (data, element_type, elements_owned);
+				else if (element_type.IsSubclassOf (typeof (Gst.GLib.Object)))
+					ret = Gst.GLib.Object.GetObject (data, false);
+				else if (element_type.IsSubclassOf (typeof (Gst.GLib.Opaque)))
+					ret = Gst.GLib.Opaque.GetOpaque (data, element_type, elements_owned);
 				else if (element_type == typeof (int))
 					ret = (int) data;
 				else if (element_type.IsValueType)
@@ -175,7 +175,7 @@
 					ret = Activator.CreateInstance (element_type, new object[] {data});
 
 			} else if (Object.IsObject (data))
-				ret = GLib.Object.GetObject (data, false);
+				ret = Gst.GLib.Object.GetObject (data, false);
 
 			return ret;
 		}
@@ -190,10 +190,10 @@
 		{
 			if (elements_owned)
 				for (uint i = 0; i < Count; i++)
-					if (typeof (GLib.Object).IsAssignableFrom (element_type))
+					if (typeof (Gst.GLib.Object).IsAssignableFrom (element_type))
 						g_object_unref (NthData (i));
-					else if (typeof (GLib.Opaque).IsAssignableFrom (element_type))
-						GLib.Opaque.GetOpaque (NthData (i), element_type, true).Dispose ();
+					else if (typeof (Gst.GLib.Opaque).IsAssignableFrom (element_type))
+						Gst.GLib.Opaque.GetOpaque (NthData (i), element_type, true).Dispose ();
 					else 
 						g_free (NthData (i));
 
--- glib-sharp-upstream/List.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/List.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/Log.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Log.cs	2009-10-03 11:59:51.000000000 +0200
@@ -22,7 +22,7 @@
 
 //
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -39,7 +39,7 @@
 		FlagRecursion          = 1 << 0,
 		FlagFatal              = 1 << 1,
 
-		/* GLib log levels */
+		/* Gst.GLib log levels */
 		Error                  = 1 << 2,       /* always fatal */
 		Critical               = 1 << 3,
 		Warning                = 1 << 4,
--- glib-sharp-upstream/MainContext.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/MainContext.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.MainContext.cs - mainContext class implementation
+// Gst.GLib.MainContext.cs - mainContext class implementation
 //
 // Author: Radek Doulik <rodo@matfyz.cz>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/MainLoop.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/MainLoop.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.MainLoop.cs - g_main_loop class implementation
+// Gst.GLib.MainLoop.cs - g_main_loop class implementation
 //
 // Author: Jeroen Zwartepoorte <jeroen@xs4all.nl>
 //
@@ -21,7 +21,7 @@
 using System;
 using System.Runtime.InteropServices;
 
-namespace GLib {
+namespace Gst.GLib {
 	public class MainLoop {
 		private IntPtr handle;
 	
--- glib-sharp-upstream/ManagedValue.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/ManagedValue.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.ManagedValue.cs : Managed types boxer
+// Gst.GLib.ManagedValue.cs : Managed types boxer
 //
 // Author: Rachel Hestilow <hestilow@ximian.com>
 //
@@ -19,11 +19,11 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 	using System;
 	using System.Collections;
 	using System.Runtime.InteropServices;
-	using GLib;
+	using Gst.GLib;
 	
 	internal class ManagedValue {
 
@@ -76,8 +76,8 @@
 					copy = new CopyFunc (Copy);
 					free = new FreeFunc (Free);
 				
-					IntPtr name = Marshaller.StringToPtrGStrdup ("GtkSharpValue");
-					boxed_type = new GLib.GType (g_boxed_type_register_static (name, copy, free));
+					IntPtr name = Marshaller.StringToPtrGStrdup ("GstGLibSharpValue");
+					boxed_type = new Gst.GLib.GType (g_boxed_type_register_static (name, copy, free));
 					Marshaller.Free (name);
 				}
 
--- glib-sharp-upstream/Markup.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Markup.cs	2009-10-03 11:59:51.000000000 +0200
@@ -23,7 +23,7 @@
 using System;
 using System.Runtime.InteropServices;
 
-namespace GLib {
+namespace Gst.GLib {
 
 
 	public class Markup {
--- glib-sharp-upstream/Marshaller.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Marshaller.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLibSharp.Marshaller.cs : Marshalling utils 
+// Gst.GLibSharp.Marshaller.cs : Marshalling utils 
 //
 // Author: Rachel Hestilow <rachel@nullenvoid.com>
 //         Mike Kestner  <mkestner@ximian.com>
@@ -21,7 +21,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 	using System;
 	using System.Runtime.InteropServices;
 	
@@ -56,7 +56,7 @@
 			IntPtr dummy, error;
 			IntPtr utf8 = g_filename_to_utf8 (ptr, -1, IntPtr.Zero, out dummy, out error);
 			if (error != IntPtr.Zero)
-				throw new GLib.GException (error);
+				throw new Gst.GLib.GException (error);
 			return Utf8PtrToString (utf8);
 		}
 
@@ -200,9 +200,9 @@
 			string[] members = new string[count];
 			for (int i = 0; i < count; ++i) {
 				IntPtr s = Marshal.ReadIntPtr (string_array, i * IntPtr.Size);
-				members[i] = GLib.Marshaller.PtrToStringGFree (s);
+				members[i] = Gst.GLib.Marshaller.PtrToStringGFree (s);
 			}
-			GLib.Marshaller.Free (string_array);
+			Gst.GLib.Marshaller.Free (string_array);
 			return members;
 		}
 
@@ -262,7 +262,7 @@
 			return buf;
 		}
 
-		[Obsolete ("Use GLib.Argv instead to avoid leaks.")]
+		[Obsolete ("Use Gst.GLib.Argv instead to avoid leaks.")]
 		public static IntPtr ArgvToArrayPtr (string[] args)
 		{
 			if (args.Length == 0)
@@ -303,7 +303,7 @@
 			return args;
 		}		
 
-		[Obsolete ("Use GLib.Argv instead to avoid leaks.")]
+		[Obsolete ("Use Gst.GLib.Argv instead to avoid leaks.")]
 		public static string[] ArrayPtrToArgv (IntPtr array, int argc)
 		{
 			if (argc == 0)
@@ -379,10 +379,10 @@
 		{
 			Type array_type = elem_type == typeof (ListBase.FilenameString) ? typeof (string) : elem_type;
 			ListBase list;
-			if (list_type == typeof(GLib.List))
-				list = new GLib.List (list_ptr, elem_type, owned, elements_owned);
+			if (list_type == typeof(Gst.GLib.List))
+				list = new Gst.GLib.List (list_ptr, elem_type, owned, elements_owned);
 			else
-				list = new GLib.SList (list_ptr, elem_type, owned, elements_owned);
+				list = new Gst.GLib.SList (list_ptr, elem_type, owned, elements_owned);
 
 			using (list)
 				return ListToArray (list, array_type);
@@ -390,7 +390,7 @@
 
 		public static Array PtrArrayToArray (IntPtr list_ptr, bool owned, bool elements_owned, Type elem_type)
 		{
-			GLib.PtrArray array = new GLib.PtrArray (list_ptr, elem_type, owned, elements_owned);
+			Gst.GLib.PtrArray array = new Gst.GLib.PtrArray (list_ptr, elem_type, owned, elements_owned);
 			Array ret = Array.CreateInstance (elem_type, array.Count);
 			array.CopyTo (ret, 0);
 			array.Dispose ();
@@ -403,7 +403,7 @@
 			if (list.Count > 0)
 				list.CopyTo (result, 0);
 
-			if (type.IsSubclassOf (typeof (GLib.Opaque)))
+			if (type.IsSubclassOf (typeof (Gst.GLib.Opaque)))
 				list.elements_owned = false;
 
 			return result;
--- glib-sharp-upstream/MissingIntPtrCtorException.cs	2004-06-25 20:42:19.000000000 +0200
+++ glib-sharp/MissingIntPtrCtorException.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/NotifyHandler.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/NotifyHandler.cs	2009-10-03 11:59:51.000000000 +0200
@@ -14,14 +14,14 @@
 // Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 // Boston, MA 02111-1307, USA.
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
 
 	public delegate void NotifyHandler (object o, NotifyArgs args);
 
-	public class NotifyArgs : GLib.SignalArgs {
+	public class NotifyArgs : Gst.GLib.SignalArgs {
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
 		static extern IntPtr g_param_spec_get_name (IntPtr pspec);
 
--- glib-sharp-upstream/Object.cs	2009-09-12 03:01:12.000000000 +0200
+++ glib-sharp/Object.cs	2009-10-03 11:59:51.000000000 +0200
@@ -20,7 +20,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -118,7 +118,7 @@
 			if (!owned_ref)
 				g_object_ref (o);
 
-			obj = GLib.ObjectManager.CreateObject(o); 
+			obj = Gst.GLib.ObjectManager.CreateObject(o); 
 			if (obj == null) {
 				g_object_unref (o);
 				return null;
@@ -163,7 +163,7 @@
 					m.Invoke (null, parms);
 			}
 
-			for (Type curr = t; curr != typeof(GLib.Object); curr = curr.BaseType) {
+			for (Type curr = t; curr != typeof(Gst.GLib.Object); curr = curr.BaseType) {
  
 				if (curr.Assembly.IsDefined (typeof (IgnoreClassInitializersAttribute), false))
 					continue;
@@ -227,7 +227,7 @@
 
 		static IntPtr ConstructorCallback (IntPtr gtypeval, uint n_construct_properties, IntPtr construct_properties)
 		{
-			GType gtype = new GLib.GType (gtypeval);
+			GType gtype = new Gst.GLib.GType (gtypeval);
 			GObjectClass threshold_class = (GObjectClass) Marshal.PtrToStructure (gtype.GetThresholdType ().GetClassPtr (), typeof (GObjectClass));
 			IntPtr raw = threshold_class.constructor_cb (gtypeval, n_construct_properties, construct_properties);
 			bool construct_needed = true;
@@ -241,7 +241,7 @@
 				Value val = (Value) Marshal.PtrToStructure (Marshal.ReadIntPtr (p, IntPtr.Size), typeof (Value));
 				if ((IntPtr) val.Val != IntPtr.Zero) {
 					GCHandle gch = (GCHandle) (IntPtr) val.Val;
-					Object o = (GLib.Object) gch.Target;
+					Object o = (Gst.GLib.Object) gch.Target;
 					o.Raw = raw;
 					construct_needed = false;
 					break;
@@ -281,7 +281,7 @@
 			foreach (PropertyInfo pinfo in t.GetProperties (BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly)) {
 				foreach (object attr in pinfo.GetCustomAttributes (typeof (PropertyAttribute), false)) {
 					if(pinfo.GetIndexParameters().Length > 0)
-						throw(new InvalidOperationException(String.Format("GLib.RegisterPropertyAttribute cannot be applied to property {0} of type {1} because the property expects one or more indexed parameters", pinfo.Name, t.FullName)));
+						throw(new InvalidOperationException(String.Format("Gst.GLib.RegisterPropertyAttribute cannot be applied to property {0} of type {1} because the property expects one or more indexed parameters", pinfo.Name, t.FullName)));
 					
 					if (!handlers_overridden) {
 						IntPtr class_ptr = gtype.GetClassPtr ();
@@ -297,21 +297,21 @@
 						Properties.Add (param_spec, pinfo);
 						idx++;
 					} catch (ArgumentException) {
-						throw new InvalidOperationException (String.Format ("GLib.PropertyAttribute cannot be applied to property {0} of type {1} because the return type of the property is not supported", pinfo.Name, t.FullName));
+						throw new InvalidOperationException (String.Format ("Gst.GLib.PropertyAttribute cannot be applied to property {0} of type {1} because the return type of the property is not supported", pinfo.Name, t.FullName));
 					}
 				}
 			}
 		}
 		
 		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
-		delegate void GetPropertyDelegate (IntPtr GObject, uint property_id, ref GLib.Value value, IntPtr pspec);
+		delegate void GetPropertyDelegate (IntPtr GObject, uint property_id, ref Gst.GLib.Value value, IntPtr pspec);
 
-		static void GetPropertyCallback (IntPtr handle, uint property_id, ref GLib.Value value, IntPtr param_spec)
+		static void GetPropertyCallback (IntPtr handle, uint property_id, ref Gst.GLib.Value value, IntPtr param_spec)
 		{
 			if (!Properties.Contains (param_spec))
 				return;
 
-			GLib.Object obj = GLib.Object.GetObject (handle, false);
+			Gst.GLib.Object obj = Gst.GLib.Object.GetObject (handle, false);
 			value.Val = (Properties [param_spec] as PropertyInfo).GetValue (obj, new object [0]);
 		}
 
@@ -325,14 +325,14 @@
 		}
 
 		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
-		delegate void SetPropertyDelegate (IntPtr GObject, uint property_id, ref GLib.Value value, IntPtr pspec);
+		delegate void SetPropertyDelegate (IntPtr GObject, uint property_id, ref Gst.GLib.Value value, IntPtr pspec);
 
-		static void SetPropertyCallback(IntPtr handle, uint property_id, ref GLib.Value value, IntPtr param_spec)
+		static void SetPropertyCallback(IntPtr handle, uint property_id, ref Gst.GLib.Value value, IntPtr param_spec)
 		{
 			if (!Properties.Contains (param_spec))
 				return;
 
-			GLib.Object obj = GLib.Object.GetObject (handle, false);
+			Gst.GLib.Object obj = Gst.GLib.Object.GetObject (handle, false);
 			(Properties [param_spec] as PropertyInfo).SetValue (obj, value.Val, new object [0]);
 		}
 
@@ -386,7 +386,7 @@
 			if (Handle != IntPtr.Zero) {
 				GTypeInstance obj = (GTypeInstance) Marshal.PtrToStructure (Handle, typeof (GTypeInstance));
 				GTypeClass klass = (GTypeClass) Marshal.PtrToStructure (obj.g_class, typeof (GTypeClass));
-				return new GLib.GType (klass.gtype);
+				return new Gst.GLib.GType (klass.gtype);
 			} else {
 				return LookupGType (GetType ());
 			}
@@ -404,7 +404,7 @@
 
 		protected Object ()
 		{
-			CreateNativeObject (new string [0], new GLib.Value [0]);
+			CreateNativeObject (new string [0], new Gst.GLib.Value [0]);
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
@@ -412,26 +412,26 @@
 
 		struct GParameter {
 			public IntPtr name;
-			public GLib.Value val;
+			public Gst.GLib.Value val;
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
 		static extern IntPtr g_object_newv (IntPtr gtype, int n_params, GParameter[] parms);
 
-		protected virtual void CreateNativeObject (string[] names, GLib.Value[] vals)
+		protected virtual void CreateNativeObject (string[] names, Gst.GLib.Value[] vals)
 		{
 			GType gtype = LookupGType ();
-			bool is_managed_subclass = gtype.ToString ().StartsWith ("__gtksharp");
+			bool is_managed_subclass = gtype.ToString ().StartsWith ("__gst_gtksharp");
 			GParameter[] parms = new GParameter [is_managed_subclass ? names.Length + 1 : names.Length];
 			for (int i = 0; i < names.Length; i++) {
-				parms [i].name = GLib.Marshaller.StringToPtrGStrdup (names [i]);
+				parms [i].name = Gst.GLib.Marshaller.StringToPtrGStrdup (names [i]);
 				parms [i].val = vals [i];
 			}
 
 			if (is_managed_subclass) {
 				GCHandle gch = GCHandle.Alloc (this);
-				parms[names.Length].name = GLib.Marshaller.StringToPtrGStrdup ("gtk-sharp-managed-instance");
-				parms[names.Length].val = new GLib.Value ((IntPtr) gch);
+				parms[names.Length].name = Gst.GLib.Marshaller.StringToPtrGStrdup ("gtk-sharp-managed-instance");
+				parms[names.Length].val = new Gst.GLib.Value ((IntPtr) gch);
 				Raw = g_object_newv (gtype.Val, parms.Length, parms);
 				gch.Free ();
 			} else {
@@ -439,7 +439,7 @@
 			}
 
 			foreach (GParameter p in parms)
-				GLib.Marshaller.Free (p.name);
+				Gst.GLib.Marshaller.Free (p.name);
 		}
 
 		protected virtual IntPtr Raw {
@@ -465,7 +465,7 @@
 			}
 		}	
 
-		public static GLib.GType GType {
+		public static Gst.GLib.GType GType {
 			get {
 				return GType.Object;
 			}
@@ -477,7 +477,7 @@
 			}
 		}
 
-		internal GLib.GType NativeType {
+		internal Gst.GLib.GType NativeType {
 			get {
 				return LookupGType ();
 			}
@@ -502,7 +502,7 @@
 		}
 
 		Hashtable before_signals;
-		[Obsolete ("Replaced by GLib.Signal marshaling mechanism.")]
+		[Obsolete ("Replaced by Gst.GLib.Signal marshaling mechanism.")]
 		protected internal Hashtable BeforeSignals {
 			get {
 				if (before_signals == null)
@@ -512,7 +512,7 @@
 		}
 
 		Hashtable after_signals;
-		[Obsolete ("Replaced by GLib.Signal marshaling mechanism.")]
+		[Obsolete ("Replaced by Gst.GLib.Signal marshaling mechanism.")]
 		protected internal Hashtable AfterSignals {
 			get {
 				if (after_signals == null)
@@ -522,7 +522,7 @@
 		}
 
 		EventHandlerList before_handlers;
-		[Obsolete ("Replaced by GLib.Signal marshaling mechanism.")]
+		[Obsolete ("Replaced by Gst.GLib.Signal marshaling mechanism.")]
 		protected EventHandlerList BeforeHandlers {
 			get {
 				if (before_handlers == null)
@@ -532,7 +532,7 @@
 		}
 
 		EventHandlerList after_handlers;
-		[Obsolete ("Replaced by GLib.Signal marshaling mechanism.")]
+		[Obsolete ("Replaced by Gst.GLib.Signal marshaling mechanism.")]
 		protected EventHandlerList AfterHandlers {
 			get {
 				if (after_handlers == null)
@@ -547,7 +547,7 @@
 		void NotifyCallback (IntPtr handle, IntPtr pspec, IntPtr gch)
 		{
 			try {
-				GLib.Signal sig = ((GCHandle) gch).Target as GLib.Signal;
+				Gst.GLib.Signal sig = ((GCHandle) gch).Target as Gst.GLib.Signal;
 				if (sig == null)
 					throw new Exception("Unknown signal GC handle received " + gch);
 
@@ -555,7 +555,7 @@
 				args.Args = new object[1];
 				args.Args[0] = pspec;
 				NotifyHandler handler = (NotifyHandler) sig.Handler;
-				handler (GLib.Object.GetObject (handle), args);
+				handler (Gst.GLib.Object.GetObject (handle), args);
 			} catch (Exception e) {
 				ExceptionManager.RaiseUnhandledException (e, false);
 			}
@@ -618,25 +618,25 @@
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_object_get_property (IntPtr obj, IntPtr name, ref GLib.Value val);
+		static extern void g_object_get_property (IntPtr obj, IntPtr name, ref Gst.GLib.Value val);
 
-		protected GLib.Value GetProperty (string name)
+		protected Gst.GLib.Value GetProperty (string name)
 		{
 			Value val = new Value (this, name);
-			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
+			IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (name);
 			g_object_get_property (Raw, native_name, ref val);
-			GLib.Marshaller.Free (native_name);
+			Gst.GLib.Marshaller.Free (native_name);
 			return val;
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_object_set_property (IntPtr obj, IntPtr name, ref GLib.Value val);
+		static extern void g_object_set_property (IntPtr obj, IntPtr name, ref Gst.GLib.Value val);
 
-		protected void SetProperty (string name, GLib.Value val)
+		protected void SetProperty (string name, Gst.GLib.Value val)
 		{
-			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
+			IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (name);
 			g_object_set_property (Raw, native_name, ref val);
-			GLib.Marshaller.Free (native_name);
+			Gst.GLib.Marshaller.Free (native_name);
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
@@ -644,9 +644,9 @@
 
 		protected void Notify (string property_name)
 		{
-			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (property_name);
+			IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (property_name);
 			g_object_notify (Handle, native_name);
-			GLib.Marshaller.Free (native_name);
+			Gst.GLib.Marshaller.Free (native_name);
 		}
 
 		protected static void OverrideVirtualMethod (GType gtype, string name, Delegate cb)
@@ -655,7 +655,7 @@
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		protected static extern void g_signal_chain_from_overridden (IntPtr args, ref GLib.Value retval);
+		protected static extern void g_signal_chain_from_overridden (IntPtr args, ref Gst.GLib.Value retval);
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
 		static extern bool g_type_check_instance_is_a (IntPtr obj, IntPtr gtype);
@@ -690,7 +690,7 @@
 		static Object ()
 		{
 			if (Environment.GetEnvironmentVariable ("GTK_SHARP_DEBUG") != null)
-				GLib.Log.SetLogHandler ("GLib-GObject", GLib.LogLevelFlags.All, new GLib.LogFunc (GLib.Log.PrintTraceLogFunction));
+				Gst.GLib.Log.SetLogHandler ("Gst.GLib-GObject", Gst.GLib.LogLevelFlags.All, new Gst.GLib.LogFunc (Gst.GLib.Log.PrintTraceLogFunction));
 		}
 	}
 }
--- glib-sharp-upstream/ObjectManager.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/ObjectManager.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.ObjectManager.cs - GLib ObjectManager class implementation
+// Gst.GLib.ObjectManager.cs - Gst.GLib ObjectManager class implementation
 //
 // Author: Mike Kestner <mkestner@speakeasy.net>
 //
@@ -20,7 +20,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
@@ -30,7 +30,7 @@
 
 		static BindingFlags flags = BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.CreateInstance;
 
-		public static GLib.Object CreateObject (IntPtr raw)
+		public static Gst.GLib.Object CreateObject (IntPtr raw)
 		{
 			if (raw == IntPtr.Zero)
 				return null;
@@ -40,11 +40,11 @@
 			if (type == null)
 				return null;
 
-			GLib.Object obj;
+			Gst.GLib.Object obj;
 			try {
-				obj = Activator.CreateInstance (type, flags, null, new object[] {raw}, null) as GLib.Object;
+				obj = Activator.CreateInstance (type, flags, null, new object[] {raw}, null) as Gst.GLib.Object;
 			} catch (MissingMethodException) {
-				throw new GLib.MissingIntPtrCtorException ("GLib.Object subclass " + type + " must provide a protected or public IntPtr ctor to support wrapping of native object handles.");
+				throw new Gst.GLib.MissingIntPtrCtorException ("Gst.GLib.Object subclass " + type + " must provide a protected or public IntPtr ctor to support wrapping of native object handles.");
 			}
 			return obj;
 		}
--- glib-sharp-upstream/Opaque.cs	2009-01-29 17:26:09.000000000 +0100
+++ glib-sharp/Opaque.cs	2009-10-03 11:59:51.000000000 +0200
@@ -24,7 +24,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
--- glib-sharp-upstream/ParamSpec.cs	2009-09-12 03:01:12.000000000 +0200
+++ glib-sharp/ParamSpec.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
@@ -42,9 +42,9 @@
 		{
 			int flags = (int) pflags;
 
-			IntPtr p_name = GLib.Marshaller.StringToPtrGStrdup (name);
-			IntPtr p_nick = GLib.Marshaller.StringToPtrGStrdup (nick);
-			IntPtr p_blurb = GLib.Marshaller.StringToPtrGStrdup (blurb);
+			IntPtr p_name = Gst.GLib.Marshaller.StringToPtrGStrdup (name);
+			IntPtr p_nick = Gst.GLib.Marshaller.StringToPtrGStrdup (nick);
+			IntPtr p_blurb = Gst.GLib.Marshaller.StringToPtrGStrdup (blurb);
 
 			if (type == GType.Char)
 				handle = g_param_spec_char (p_name, p_nick, p_blurb, SByte.MinValue, SByte.MaxValue, 0, flags);
@@ -87,9 +87,9 @@
 			else
 				throw new ArgumentException ("type");
 
-			GLib.Marshaller.Free (p_name);
-			GLib.Marshaller.Free (p_nick);
-			GLib.Marshaller.Free (p_blurb);
+			Gst.GLib.Marshaller.Free (p_name);
+			Gst.GLib.Marshaller.Free (p_nick);
+			Gst.GLib.Marshaller.Free (p_blurb);
 		}
 
 		public ParamSpec (IntPtr native)
--- glib-sharp-upstream/Priority.cs	2009-05-03 21:34:22.000000000 +0200
+++ glib-sharp/Priority.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Priority.cs
+// Gst.GLib.Priority.cs
 //
 // Author(s):
 //	Stephane Delcroix <stephane@delcroix.org>
@@ -19,7 +19,7 @@
 // Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 // Boston, MA 02111-1307, USA.
 
-namespace GLib {
+namespace Gst.GLib {
 	public enum Priority
 	{
 		High = -100,
--- glib-sharp-upstream/PropertyAttribute.cs	2008-06-06 18:55:00.000000000 +0200
+++ glib-sharp/PropertyAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -17,7 +17,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/PtrArray.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/PtrArray.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -94,10 +94,10 @@
 			if (elements_owned) {
 				int count = Count;
 				for (uint i = 0; i < count; i++)
-					if (typeof (GLib.Object).IsAssignableFrom (element_type))
+					if (typeof (Gst.GLib.Object).IsAssignableFrom (element_type))
 						g_object_unref (NthData (i));
-					else if (typeof (GLib.Opaque).IsAssignableFrom (element_type))
-						GLib.Opaque.GetOpaque (NthData (i), element_type, true).Dispose ();
+					else if (typeof (Gst.GLib.Opaque).IsAssignableFrom (element_type))
+						Gst.GLib.Opaque.GetOpaque (NthData (i), element_type, true).Dispose ();
 					else 
 						g_free (NthData (i));
 			}
@@ -174,10 +174,10 @@
 					ret = Marshaller.Utf8PtrToString (data);
 				else if (element_type == typeof (IntPtr))
 					ret = data;
-				else if (element_type.IsSubclassOf (typeof (GLib.Object)))
-					ret = GLib.Object.GetObject (data, false);
-				else if (element_type.IsSubclassOf (typeof (GLib.Opaque)))
-					ret = GLib.Opaque.GetOpaque (data, element_type, elements_owned);
+				else if (element_type.IsSubclassOf (typeof (Gst.GLib.Object)))
+					ret = Gst.GLib.Object.GetObject (data, false);
+				else if (element_type.IsSubclassOf (typeof (Gst.GLib.Opaque)))
+					ret = Gst.GLib.Opaque.GetOpaque (data, element_type, elements_owned);
 				else if (element_type == typeof (int))
 					ret = (int) data;
 				else if (element_type.IsValueType)
@@ -186,7 +186,7 @@
 					ret = Activator.CreateInstance (element_type, new object[] {data});
 
 			} else if (Object.IsObject (data))
-				ret = GLib.Object.GetObject (data, false);
+				ret = Gst.GLib.Object.GetObject (data, false);
 
 			return ret;
 		}
--- glib-sharp-upstream/SignalArgs.cs	2004-06-25 20:42:19.000000000 +0200
+++ glib-sharp/SignalArgs.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.SignalArgs.cs - Signal argument class implementation
+// Gst.GLib.SignalArgs.cs - Signal argument class implementation
 //
 // Author: Mike Kestner <mkestner@speakeasy.net>
 //
@@ -20,7 +20,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 	using System;
 	using System.Collections;
 
--- glib-sharp-upstream/SignalAttribute.cs	2005-10-08 23:08:04.000000000 +0200
+++ glib-sharp/SignalAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -20,7 +20,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/SignalCallback.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/SignalCallback.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.SignalCallback.cs - Signal callback base class implementation
+// Gst.GLib.SignalCallback.cs - Signal callback base class implementation
 //
 // Authors: Mike Kestner <mkestner@ximian.com>
 //
@@ -20,12 +20,12 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 	using System;
 	using System.Collections;
 	using System.Runtime.InteropServices;
 
-	[Obsolete ("Replaced by GLib.Signal.")]
+	[Obsolete ("Replaced by Gst.GLib.Signal.")]
 	public abstract class SignalCallback : IDisposable {
 
 		// A counter used to produce unique keys for instances.
@@ -35,13 +35,13 @@
 		protected static Hashtable _Instances = new Hashtable ();
 
 		// protected instance members
-		protected GLib.Object _obj;
+		protected Gst.GLib.Object _obj;
 		protected Delegate _handler;
 		protected int _key;
 		protected System.Type _argstype;
 		protected uint _HandlerID;
 
-		protected SignalCallback (GLib.Object obj, Delegate eh, System.Type argstype)
+		protected SignalCallback (Gst.GLib.Object obj, Delegate eh, System.Type argstype)
 		{
 			_key = _NextKey++;
 			_obj = obj;
--- glib-sharp-upstream/SignalClosure.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/SignalClosure.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -28,10 +28,10 @@
 	internal class ClosureInvokedArgs : EventArgs {
 
 		EventArgs args;
-		GLib.Object obj;
+		Gst.GLib.Object obj;
 		object result;
 
-		public ClosureInvokedArgs (GLib.Object obj, EventArgs args)
+		public ClosureInvokedArgs (Gst.GLib.Object obj, EventArgs args)
 		{
 			this.obj = obj;
 			this.args = args;
@@ -43,7 +43,7 @@
 			}
 		}
 
-		public GLib.Object Target {
+		public Gst.GLib.Object Target {
 			get {
 				return obj;
 			}
@@ -97,9 +97,9 @@
 
 		public void Connect (bool is_after)
 		{
-			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
+			IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (name);
 			id = g_signal_connect_closure (handle, native_name, raw_closure, is_after);
-			GLib.Marshaller.Free (native_name);
+			Gst.GLib.Marshaller.Free (native_name);
 		}
 
 		public void Disconnect ()
@@ -147,7 +147,7 @@
 				SignalClosure closure = closures [raw_closure] as SignalClosure;
 				message = "Marshaling " + closure.name + " signal";
 				Value objval = (Value) Marshal.PtrToStructure (param_values, typeof (Value));
-				GLib.Object __obj = objval.Val as GLib.Object;
+				Gst.GLib.Object __obj = objval.Val as Gst.GLib.Object;
 				if (__obj == null)
 					return;
 
@@ -158,7 +158,7 @@
 
 				SignalArgs args = Activator.CreateInstance (closure.args_type, new object [0]) as SignalArgs;
 				args.Args = new object [n_param_vals - 1];
-				GLib.Value[] vals = new GLib.Value [n_param_vals - 1];
+				Gst.GLib.Value[] vals = new Gst.GLib.Value [n_param_vals - 1];
 				for (int i = 1; i < n_param_vals; i++) {
 					IntPtr ptr = new IntPtr (param_values.ToInt64 () + i * Marshal.SizeOf (typeof (Value)));
 					vals [i - 1] = (Value) Marshal.PtrToStructure (ptr, typeof (Value));
--- glib-sharp-upstream/Signal.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Signal.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Signal.cs - signal marshaling class
+// Gst.GLib.Signal.cs - signal marshaling class
 //
 // Authors: Mike Kestner <mkestner@novell.com>
 //          Andr√©s G. Aragoneses <aaragoneses@novell.com>
@@ -20,7 +20,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -140,7 +140,7 @@
 		SignalClosure after_closure;
 		Delegate marshaler;
 
-		private Signal (GLib.Object obj, string signal_name, Delegate marshaler)
+		private Signal (Gst.GLib.Object obj, string signal_name, Delegate marshaler)
 		{
 			tref = obj.ToggleRef;
 			name = signal_name;
@@ -148,7 +148,7 @@
 			this.marshaler = marshaler;
 		}
 
-		private Signal (GLib.Object obj, string signal_name, Type args_type)
+		private Signal (Gst.GLib.Object obj, string signal_name, Type args_type)
 		{
 			tref = obj.ToggleRef;
 			name = signal_name;
@@ -215,12 +215,12 @@
 			}
 		}
 
-		public static Signal Lookup (GLib.Object obj, string name)
+		public static Signal Lookup (Gst.GLib.Object obj, string name)
 		{
 			return Lookup (obj, name, typeof (EventArgs));
 		}
 
-		public static Signal Lookup (GLib.Object obj, string name, Delegate marshaler)
+		public static Signal Lookup (Gst.GLib.Object obj, string name, Delegate marshaler)
 		{
 			Signal result = obj.ToggleRef.Signals [name] as Signal;
 			if (result == null)
@@ -228,7 +228,7 @@
 			return result;
 		}
 
-		public static Signal Lookup (GLib.Object obj, string name, Type args_type)
+		public static Signal Lookup (Gst.GLib.Object obj, string name, Type args_type)
 		{
 			Signal result = obj.ToggleRef.Signals [name] as Signal;
 			if (result == null)
@@ -313,7 +313,7 @@
 			}
 		}
 		
-		public static object Emit (GLib.Object instance, string detailed_signal, params object[] args)
+		public static object Emit (Gst.GLib.Object instance, string detailed_signal, params object[] args)
 		{
 			uint gquark, signal_id;
 			string signal_name;
@@ -321,13 +321,13 @@
 			signal_id = GetSignalId (signal_name, instance);
 			if (signal_id <= 0)
 				throw new ArgumentException ("Invalid signal name: " + signal_name);
-			GLib.Value[] vals = new GLib.Value [args.Length + 1];
-			GLib.ValueArray inst_and_params = new GLib.ValueArray ((uint) args.Length + 1);
+			Gst.GLib.Value[] vals = new Gst.GLib.Value [args.Length + 1];
+			Gst.GLib.ValueArray inst_and_params = new Gst.GLib.ValueArray ((uint) args.Length + 1);
 			
-			vals [0] = new GLib.Value (instance);
+			vals [0] = new Gst.GLib.Value (instance);
 			inst_and_params.Append (vals [0]);
 			for (int i = 1; i < vals.Length; i++) {
-				vals [i] = new GLib.Value (args [i - 1]);
+				vals [i] = new Gst.GLib.Value (args [i - 1]);
 				inst_and_params.Append (vals [i]);
 			}
 
@@ -335,27 +335,27 @@
 			Query query;
 			g_signal_query (signal_id, out query);
 			if (query.return_type != GType.None.Val) {
-				GLib.Value ret = GLib.Value.Empty;
+				Gst.GLib.Value ret = Gst.GLib.Value.Empty;
 				g_signal_emitv (inst_and_params.ArrayPtr, signal_id, gquark, ref ret);
 				ret_obj = ret.Val;
 				ret.Dispose ();
 			} else
 				g_signal_emitv (inst_and_params.ArrayPtr, signal_id, gquark, IntPtr.Zero);
 			
-			foreach (GLib.Value val in vals)
+			foreach (Gst.GLib.Value val in vals)
 				val.Dispose ();
 
 			return ret_obj;
 		}
 		
 		private static uint GetGQuarkFromString (string str) {
-			IntPtr native_string = GLib.Marshaller.StringToPtrGStrdup (str);
+			IntPtr native_string = Gst.GLib.Marshaller.StringToPtrGStrdup (str);
 			uint ret = g_quark_from_string (native_string);
-			GLib.Marshaller.Free (native_string);
+			Gst.GLib.Marshaller.Free (native_string);
 			return ret;
 		}
 
-		private static uint GetSignalId (string signal_name, GLib.Object obj)
+		private static uint GetSignalId (string signal_name, Gst.GLib.Object obj)
 		{
 			IntPtr typeid = GType.ValFromInstancePtr (obj.Handle);
 			return GetSignalId (signal_name, typeid);
@@ -363,13 +363,13 @@
 		
 		private static uint GetSignalId (string signal_name, IntPtr typeid)
 		{
-			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (signal_name);
+			IntPtr native_name = Gst.GLib.Marshaller.StringToPtrGStrdup (signal_name);
 			uint signal_id = g_signal_lookup (native_name, typeid);
-			GLib.Marshaller.Free (native_name);
+			Gst.GLib.Marshaller.Free (native_name);
 			return signal_id;
 		}
 		
-		public static ulong AddEmissionHook (string detailed_signal, GLib.GType type, EmissionHook handler_func)
+		public static ulong AddEmissionHook (string detailed_signal, Gst.GLib.GType type, EmissionHook handler_func)
 		{
 			uint gquark;
 			string signal_name;
@@ -395,7 +395,7 @@
 		static extern IntPtr g_signal_get_invocation_hint (IntPtr instance);
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_signal_emitv (IntPtr instance_and_params, uint signal_id, uint gquark_detail, ref GLib.Value return_value);
+		static extern void g_signal_emitv (IntPtr instance_and_params, uint signal_id, uint gquark_detail, ref Gst.GLib.Value return_value);
 		
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
 		static extern void g_signal_emitv (IntPtr instance_and_params, uint signal_id, uint gquark_detail, IntPtr return_value);
--- glib-sharp-upstream/SList.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/SList.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
--- glib-sharp-upstream/Source.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Source.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Source.cs - Source class implementation
+// Gst.GLib.Source.cs - Source class implementation
 //
 // Author: Duncan Mak  <duncan@ximian.com>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
--- glib-sharp-upstream/Spawn.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Spawn.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
@@ -126,7 +126,7 @@
 			Marshaller.Free (native_dir);
 			Marshaller.Free (native_argv);
 			Marshaller.Free (native_envp);
-			if (error != IntPtr.Zero) throw new GLib.GException (error);
+			if (error != IntPtr.Zero) throw new Gst.GLib.GException (error);
 			return result;
 		}  
 
@@ -161,7 +161,7 @@
 			Marshaller.Free (native_dir);
 			Marshaller.Free (native_argv);
 			Marshaller.Free (native_envp);
-			if (error != IntPtr.Zero) throw new GLib.GException (error);
+			if (error != IntPtr.Zero) throw new Gst.GLib.GException (error);
 			return result;
 		}  
 
@@ -181,7 +181,7 @@
 			Marshaller.Free (native_envp);
 			stdout = Marshaller.PtrToStringGFree (native_stdout);
 			stderr = Marshaller.PtrToStringGFree (native_stderr);
-			if (error != IntPtr.Zero) throw new GLib.GException (error);
+			if (error != IntPtr.Zero) throw new Gst.GLib.GException (error);
 			return result;
 		}  
 
@@ -194,7 +194,7 @@
 			IntPtr native_cmd = Marshaller.StringToPtrGStrdup (command_line);
 			bool result = g_spawn_command_line_async (native_cmd, out error);
 			Marshaller.Free (native_cmd);
-			if (error != IntPtr.Zero) throw new GLib.GException (error);
+			if (error != IntPtr.Zero) throw new Gst.GLib.GException (error);
 			return result;
 		}
 
@@ -209,7 +209,7 @@
 			Marshaller.Free (native_cmd);
 			stdout = Marshaller.PtrToStringGFree (native_stdout);
 			stderr = Marshaller.PtrToStringGFree (native_stderr);
-			if (error != IntPtr.Zero) throw new GLib.GException (error);
+			if (error != IntPtr.Zero) throw new Gst.GLib.GException (error);
 			return result;
 		}
 	}
--- glib-sharp-upstream/Thread.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/Thread.cs	2009-10-03 12:00:06.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib
+namespace Gst.GLib
 {
 	using System;
 	using System.Runtime.InteropServices;
@@ -36,13 +36,13 @@
 			g_thread_init (IntPtr.Zero);
 		}
 
-		[DllImport("glibsharpglue-3")]
-		static extern bool glibsharp_g_thread_supported ();
+		[DllImport("gstreamersharpglue-0.10.dll")]
+		static extern bool gstglibsharp_g_thread_supported ();
 
 		public static bool Supported
 		{
 			get {
-				return glibsharp_g_thread_supported ();
+				return gstglibsharp_g_thread_supported ();
 			}
 		}
 	}
--- glib-sharp-upstream/Timeout.cs	2009-09-22 04:52:41.000000000 +0200
+++ glib-sharp/Timeout.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Timeout.cs - Timeout class implementation
+// Gst.GLib.Timeout.cs - Timeout class implementation
 //
 // Author(s):
 //	Mike Kestner <mkestner@speakeasy.net>
@@ -22,7 +22,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
--- glib-sharp-upstream/ToggleRef.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/ToggleRef.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.ToggleRef.cs - GLib ToggleRef class implementation
+// Gst.GLib.ToggleRef.cs - Gst.GLib ToggleRef class implementation
 //
 // Author: Mike Kestner <mkestner@novell.com>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -33,7 +33,7 @@
 		GCHandle gch;
 		Hashtable signals;
 
-		public ToggleRef (GLib.Object target)
+		public ToggleRef (Gst.GLib.Object target)
 		{
 			handle = target.Handle;
 			gch = GCHandle.Alloc (this);
@@ -67,15 +67,15 @@
 			}
 		}
 
-		public GLib.Object Target {
+		public Gst.GLib.Object Target {
 			get {
 				if (reference == null)
 					return null;
-				else if (reference is GLib.Object)
-					return reference as GLib.Object;
+				else if (reference is Gst.GLib.Object)
+					return reference as Gst.GLib.Object;
 
 				WeakReference weak = reference as WeakReference;
-				return weak.Target as GLib.Object;
+				return weak.Target as Gst.GLib.Object;
 			}
 		}
 
@@ -111,7 +111,7 @@
 
 		void Toggle (bool is_last_ref)
 		{
-			if (is_last_ref && reference is GLib.Object)
+			if (is_last_ref && reference is Gst.GLib.Object)
 				reference = new WeakReference (reference);
 			else if (!is_last_ref && reference is WeakReference) {
 				WeakReference weak = reference as WeakReference;
--- glib-sharp-upstream/TypeConverter.cs	2005-05-04 18:54:24.000000000 +0200
+++ glib-sharp/TypeConverter.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.TypeConverter.cs : Convert between fundamental and .NET types 
+// Gst.GLib.TypeConverter.cs : Convert between fundamental and .NET types 
 //
 // Author: Rachel Hestilow <hestilow@ximian.com>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 	using System;
 
 	public class TypeConverter {
--- glib-sharp-upstream/TypeFundamentals.cs	2004-07-09 17:25:39.000000000 +0200
+++ glib-sharp/TypeFundamentals.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.TypeFundamentals.cs : Standard Types enumeration 
+// Gst.GLib.TypeFundamentals.cs : Standard Types enumeration 
 //
 // Author: Mike Kestner <mkestner@speakeasy.net>
 //
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	public enum TypeFundamentals {
 		TypeInvalid	= 0 << 2,
--- glib-sharp-upstream/TypeInitializerAttribute.cs	2007-09-07 16:40:46.000000000 +0200
+++ glib-sharp/TypeInitializerAttribute.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 
--- glib-sharp-upstream/UnwrappedObject.cs	2005-07-22 20:36:50.000000000 +0200
+++ glib-sharp/UnwrappedObject.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,12 +19,12 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Runtime.InteropServices;
 	
-	[Obsolete ("Replaced by direct object-type casts to/from GLib.Value")]
+	[Obsolete ("Replaced by direct object-type casts to/from Gst.GLib.Value")]
 	public class UnwrappedObject {
 		IntPtr obj;
 		
--- glib-sharp-upstream/ValueArray.cs	2009-09-03 21:50:53.000000000 +0200
+++ glib-sharp/ValueArray.cs	2009-10-03 11:59:51.000000000 +0200
@@ -19,7 +19,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -116,25 +116,25 @@
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_value_array_append (IntPtr raw, ref GLib.Value val);
+		static extern void g_value_array_append (IntPtr raw, ref Gst.GLib.Value val);
 
-		public void Append (GLib.Value val)
+		public void Append (Gst.GLib.Value val)
 		{
 			g_value_array_append (Handle, ref val);
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_value_array_insert (IntPtr raw, uint idx, ref GLib.Value val);
+		static extern void g_value_array_insert (IntPtr raw, uint idx, ref Gst.GLib.Value val);
 
-		public void Insert (uint idx, GLib.Value val)
+		public void Insert (uint idx, Gst.GLib.Value val)
 		{
 			g_value_array_insert (Handle, idx, ref val);
 		}
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_value_array_prepend (IntPtr raw, ref GLib.Value val);
+		static extern void g_value_array_prepend (IntPtr raw, ref Gst.GLib.Value val);
 
-		public void Prepend (GLib.Value val)
+		public void Prepend (Gst.GLib.Value val)
 		{
 			g_value_array_prepend (Handle, ref val);
 		}
@@ -158,7 +158,7 @@
 		public object this [int index] { 
 			get { 
 				IntPtr raw_val = g_value_array_get_nth (Handle, (uint) index);
-				return Marshal.PtrToStructure (raw_val, typeof (GLib.Value));
+				return Marshal.PtrToStructure (raw_val, typeof (Gst.GLib.Value));
 			}
 		}
 
@@ -238,9 +238,9 @@
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
 		static extern IntPtr g_value_array_get_type ();
 
-		public static GLib.GType GType {
+		public static Gst.GLib.GType GType {
 			get {
-				return new GLib.GType (g_value_array_get_type ());
+				return new Gst.GLib.GType (g_value_array_get_type ());
 			}
 		}
 	}
--- glib-sharp-upstream/Value.cs	2009-09-24 19:21:16.000000000 +0200
+++ glib-sharp/Value.cs	2009-10-03 11:59:51.000000000 +0200
@@ -1,4 +1,4 @@
-// GLib.Value.cs - GLib Value class implementation
+// Gst.GLib.Value.cs - Gst.GLib Value class implementation
 //
 // Author: Mike Kestner <mkestner@speakeasy.net>
 //
@@ -20,7 +20,7 @@
 // Boston, MA 02111-1307, USA.
 
 
-namespace GLib {
+namespace Gst.GLib {
 
 	using System;
 	using System.Collections;
@@ -49,7 +49,7 @@
 
 		public static Value Empty;
 
-		public Value (GLib.GType gtype)
+		public Value (Gst.GLib.GType gtype)
 		{
 			type = IntPtr.Zero;
 			pad1 = new Padding ();
@@ -133,9 +133,9 @@
 
 		public Value (string val) : this (GType.String)
 		{
-			IntPtr native_val = GLib.Marshaller.StringToPtrGStrdup (val);
+			IntPtr native_val = Gst.GLib.Marshaller.StringToPtrGStrdup (val);
 			g_value_set_string (ref this, native_val); 
-			GLib.Marshaller.Free (native_val);
+			Gst.GLib.Marshaller.Free (native_val);
 		}
 
 		public Value (ValueArray val) : this (ValueArray.GType)
@@ -157,17 +157,17 @@
 			g_value_set_boxed (ref this, val.Handle);
 		}
 
-		public Value (GLib.Object val) : this (val == null ? GType.Object : val.NativeType)
+		public Value (Gst.GLib.Object val) : this (val == null ? GType.Object : val.NativeType)
 		{
 			g_value_set_object (ref this, val == null ? IntPtr.Zero : val.Handle);
 		}
 
-		public Value (GLib.GInterfaceAdapter val) : this (val == null ? GType.Object : val.GType)
+		public Value (Gst.GLib.GInterfaceAdapter val) : this (val == null ? GType.Object : val.GType)
 		{
 			g_value_set_object (ref this, val == null ? IntPtr.Zero : val.Handle);
 		}
 
-		public Value (GLib.Object obj, string prop_name)
+		public Value (Gst.GLib.Object obj, string prop_name)
 		{
 			type = IntPtr.Zero;
 			pad1 = new Padding ();
@@ -176,7 +176,7 @@
 		}
 
 		[Obsolete]
-		public Value (GLib.Object obj, string prop_name, EnumWrapper wrap)
+		public Value (Gst.GLib.Object obj, string prop_name, EnumWrapper wrap)
 		{
 			type = IntPtr.Zero;
 			pad1 = new Padding ();
@@ -194,11 +194,11 @@
 			type = IntPtr.Zero;
 			pad1 = new Padding ();
 			pad2 = new Padding ();
-			InitForProperty (GLib.Object.GetObject (obj), prop_name);
+			InitForProperty (Gst.GLib.Object.GetObject (obj), prop_name);
 			g_value_set_boxed (ref this, val.Handle);
 		}
 
-		public Value (string[] val) : this (new GLib.GType (g_strv_get_type ()))
+		public Value (string[] val) : this (new Gst.GLib.GType (g_strv_get_type ()))
 		{
 			if (val == null) {
 				g_value_set_boxed (ref this, IntPtr.Zero);
@@ -207,13 +207,13 @@
 
 			IntPtr native_array = Marshal.AllocHGlobal ((val.Length + 1) * IntPtr.Size);
 			for (int i = 0; i < val.Length; i++)
-				Marshal.WriteIntPtr (native_array, i * IntPtr.Size, GLib.Marshaller.StringToPtrGStrdup (val[i]));
+				Marshal.WriteIntPtr (native_array, i * IntPtr.Size, Gst.GLib.Marshaller.StringToPtrGStrdup (val[i]));
 			Marshal.WriteIntPtr (native_array, val.Length * IntPtr.Size, IntPtr.Zero);
 
 			g_value_set_boxed (ref this, native_array);
 
 			for (int i = 0; i < val.Length; i++)
-				GLib.Marshaller.Free (Marshal.ReadIntPtr (native_array, i * IntPtr.Size));
+				Gst.GLib.Marshaller.Free (Marshal.ReadIntPtr (native_array, i * IntPtr.Size));
 			Marshal.FreeHGlobal (native_array);
 		}
 
@@ -223,7 +223,7 @@
 			g_value_unset (ref this);
 		}
 
-		public void Init (GLib.GType gtype)
+		public void Init (Gst.GLib.GType gtype)
 		{
 			g_value_init (ref this, gtype.Val);
 		}
@@ -305,7 +305,7 @@
 		public static explicit operator string (Value val)
 		{
 			IntPtr str = g_value_get_string (ref val);
-			return str == IntPtr.Zero ? null : GLib.Marshaller.Utf8PtrToString (str);
+			return str == IntPtr.Zero ? null : Gst.GLib.Marshaller.Utf8PtrToString (str);
 		}
 
 		public static explicit operator ValueArray (Value val)
@@ -318,23 +318,23 @@
 			return g_value_get_pointer (ref val);
 		}
 
-		public static explicit operator GLib.Opaque (Value val)
+		public static explicit operator Gst.GLib.Opaque (Value val)
 		{
-			return GLib.Opaque.GetOpaque (g_value_get_boxed (ref val), (Type) new GType (val.type), false);
+			return Gst.GLib.Opaque.GetOpaque (g_value_get_boxed (ref val), (Type) new GType (val.type), false);
 		}
 
-		public static explicit operator GLib.Boxed (Value val)
+		public static explicit operator Gst.GLib.Boxed (Value val)
 		{
-			return new GLib.Boxed (g_value_get_boxed (ref val));
+			return new Gst.GLib.Boxed (g_value_get_boxed (ref val));
 		}
 
-		public static explicit operator GLib.Object (Value val)
+		public static explicit operator Gst.GLib.Object (Value val)
 		{
-			return GLib.Object.GetObject (g_value_get_object (ref val), false);
+			return Gst.GLib.Object.GetObject (g_value_get_object (ref val), false);
 		}
 
-		[Obsolete ("Replaced by GLib.Object cast")]
-		public static explicit operator GLib.UnwrappedObject (Value val)
+		[Obsolete ("Replaced by Gst.GLib.Object cast")]
+		public static explicit operator Gst.GLib.UnwrappedObject (Value val)
 		{
 			return new UnwrappedObject (g_value_get_object (ref val));
 		}
@@ -350,18 +350,18 @@
 				count++;
 			string[] strings = new string[count];
 			for (int i = 0; i < count; i++)
-				strings[i] = GLib.Marshaller.Utf8PtrToString (Marshal.ReadIntPtr (native_array, i * IntPtr.Size));
+				strings[i] = Gst.GLib.Marshaller.Utf8PtrToString (Marshal.ReadIntPtr (native_array, i * IntPtr.Size));
 			return strings;
 		}
 
 		object ToRegisteredType () {
-			Type t = GLib.GType.LookupType (type);
+			Type t = Gst.GLib.GType.LookupType (type);
 			ConstructorInfo ci = null;
 			
 			try {
 				while (ci == null && t != null) {
 					if (!t.IsAbstract)
-						ci = t.GetConstructor (new Type[] { typeof (GLib.Value) });
+						ci = t.GetConstructor (new Type[] { typeof (Gst.GLib.Value) });
 					if (ci == null)
 						t = t.BaseType;
 				}
@@ -376,12 +376,12 @@
 		}
 
 		void FromRegisteredType (object val) {
-			Type t = GLib.GType.LookupType (type);
+			Type t = Gst.GLib.GType.LookupType (type);
 			MethodInfo mi = null;
 			
 			try {
 				while (mi == null && t != null) {
-					mi = t.GetMethod ("SetGValue", new Type[] { Type.GetType ("GLib.Value&") });
+					mi = t.GetMethod ("SetGValue", new Type[] { Type.GetType ("Gst.GLib.Value&") });
 					if (mi != null && (mi.IsAbstract || mi.ReturnType != typeof (void)))
 						mi = null;
 					if (mi == null)
@@ -396,7 +396,7 @@
 			
 			object[] parameters = new object[] { this };
 			mi.Invoke (val, parameters);
-			this = (GLib.Value) parameters[0];
+			this = (Gst.GLib.Value) parameters[0];
 		}
 
 		long GetLongForPlatform ()
@@ -475,8 +475,8 @@
 			Type t = GType.LookupType (type);
 			if (t == null)
 				throw new Exception ("Unknown type " + new GType (type).ToString ());
-			else if (t.IsSubclassOf (typeof (GLib.Opaque)))
-				return (GLib.Opaque) this;
+			else if (t.IsSubclassOf (typeof (Gst.GLib.Opaque)))
+				return (Gst.GLib.Opaque) this;
 
 			MethodInfo mi = t.GetMethod ("New", BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy);
 			if (mi == null)
@@ -524,7 +524,7 @@
 				else if (type == ManagedValue.GType.Val)
 					return ManagedValue.ObjectForWrapper (g_value_get_boxed (ref this));
 				else if (GType.Is (type, GType.Object))
-					return (GLib.Object) this;
+					return (Gst.GLib.Object) this;
 				else if (GType.Is (type, GType.Boxed))
 					return ToBoxed ();
 				else if (GType.LookupType (type) != null)
@@ -562,9 +562,9 @@
 				else if (type == GType.Double.Val)
 					g_value_set_double (ref this, (double) value);
 				else if (type == GType.String.Val) {
-					IntPtr native = GLib.Marshaller.StringToPtrGStrdup ((string)value);
+					IntPtr native = Gst.GLib.Marshaller.StringToPtrGStrdup ((string)value);
 					g_value_set_string (ref this, native);
-					GLib.Marshaller.Free (native);
+					Gst.GLib.Marshaller.Free (native);
 				} else if (type == GType.Pointer.Val) {
 					if (value.GetType () == typeof (IntPtr)) {
 						g_value_set_pointer (ref this, (IntPtr) value);
@@ -585,10 +585,10 @@
 					g_value_set_boxed (ref this, wrapper);
 					ManagedValue.ReleaseWrapper (wrapper);
 				} else if (GType.Is (type, GType.Object))
-					if(value is GLib.Object)
-						g_value_set_object (ref this, (value as GLib.Object).Handle);
+					if(value is Gst.GLib.Object)
+						g_value_set_object (ref this, (value as Gst.GLib.Object).Handle);
 					else
-						g_value_set_object (ref this, (value as GLib.GInterfaceAdapter).Handle);
+						g_value_set_object (ref this, (value as Gst.GLib.GInterfaceAdapter).Handle);
 				else if (GType.Is (type, GType.Boxed)) {
 					if (value is IWrapper) {
 						g_value_set_boxed (ref this, ((IWrapper)value).Handle);
@@ -597,7 +597,7 @@
 					IntPtr buf = Marshaller.StructureToPtrAlloc (value);
 					g_value_set_boxed (ref this, buf);
 					Marshal.FreeHGlobal (buf);
-				} else if (GLib.GType.LookupType (type) != null) {
+				} else if (Gst.GLib.GType.LookupType (type) != null) {
 					FromRegisteredType (value);
 				} else
 					throw new Exception ("Unknown type " + new GType (type).ToString ());
@@ -640,10 +640,10 @@
 		static extern bool g_type_check_value_holds (ref Value val, IntPtr gtype);
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_value_init (ref GLib.Value val, IntPtr gtype);
+		static extern void g_value_init (ref Gst.GLib.Value val, IntPtr gtype);
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
-		static extern void g_value_unset (ref GLib.Value val);
+		static extern void g_value_unset (ref Gst.GLib.Value val);
 
 		[DllImport ("libgobject-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
 		static extern void g_value_set_boolean (ref Value val, bool data);
