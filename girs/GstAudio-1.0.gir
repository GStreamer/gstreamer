<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Gst" version="1.0"/>
  <include name="GstBase" version="1.0"/>
  <include name="GstTag" version="1.0"/>
  <package name="gstreamer-audio-1.0"/>
  <c:include name="gst/audio/audio.h"/>
  <namespace name="GstAudio"
             version="1.0"
             shared-library="libgstaudio-1.0.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <constant name="AUDIO_CHANNELS_RANGE"
              value="(int) [ 1, max ]"
              c:type="GST_AUDIO_CHANNELS_RANGE">
      <doc xml:space="preserve">Maximum range of allowed channels, for use in template caps strings.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_CONVERTER_OPT_DITHER_METHOD"
              value="GstAudioConverter.dither-method"
              c:type="GST_AUDIO_CONVERTER_OPT_DITHER_METHOD">
      <doc xml:space="preserve">#GST_TYPE_AUDIO_DITHER_METHOD, The dither method to use when
changing bit depth.
Default is #GST_AUDIO_DITHER_NONE.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_CONVERTER_OPT_MIX_MATRIX"
              value="GstAudioConverter.mix-matrix"
              c:type="GST_AUDIO_CONVERTER_OPT_MIX_MATRIX">
      <doc xml:space="preserve">#GST_TYPE_VALUE_LIST, The channel mapping matrix.

The matrix coefficients must be between -1 and 1: the number of rows is equal
to the number of output channels and the number of columns is equal to the
number of input channels.

## Example matrix generation code
To generate the matrix using code:

|[
GValue v = G_VALUE_INIT;
GValue v2 = G_VALUE_INIT;
GValue v3 = G_VALUE_INIT;

g_value_init (&amp;v2, GST_TYPE_ARRAY);
g_value_init (&amp;v3, G_TYPE_DOUBLE);
g_value_set_double (&amp;v3, 1);
gst_value_array_append_value (&amp;v2, &amp;v3);
g_value_unset (&amp;v3);
[ Repeat for as many double as your input channels - unset and reinit v3 ]
g_value_init (&amp;v, GST_TYPE_ARRAY);
gst_value_array_append_value (&amp;v, &amp;v2);
g_value_unset (&amp;v2);
[ Repeat for as many v2's as your output channels - unset and reinit v2]
g_object_set_property (G_OBJECT (audiomixmatrix), "matrix", &amp;v);
g_value_unset (&amp;v);
]|</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD"
              value="GstAudioConverter.noise-shaping-method"
              c:type="GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD">
      <doc xml:space="preserve">#GST_TYPE_AUDIO_NOISE_SHAPING_METHOD, The noise shaping method to use
to mask noise from quantization errors.
Default is #GST_AUDIO_NOISE_SHAPING_NONE.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_CONVERTER_OPT_QUANTIZATION"
              value="GstAudioConverter.quantization"
              c:type="GST_AUDIO_CONVERTER_OPT_QUANTIZATION">
      <doc xml:space="preserve">#G_TYPE_UINT, The quantization amount. Components will be
quantized to multiples of this value.
Default is 1</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_CONVERTER_OPT_RESAMPLER_METHOD"
              value="GstAudioConverter.resampler-method"
              c:type="GST_AUDIO_CONVERTER_OPT_RESAMPLER_METHOD">
      <doc xml:space="preserve">#GST_TYPE_AUDIO_RESAMPLER_METHOD, The resampler method to use when
changing sample rates.
Default is #GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DECODER_MAX_ERRORS"
              value="10"
              c:type="GST_AUDIO_DECODER_MAX_ERRORS">
      <doc xml:space="preserve">Default maximum number of errors tolerated before signaling error.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_DECODER_SINK_NAME"
              value="sink"
              c:type="GST_AUDIO_DECODER_SINK_NAME">
      <doc xml:space="preserve">The name of the templates for the sink pad.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DECODER_SRC_NAME"
              value="src"
              c:type="GST_AUDIO_DECODER_SRC_NAME">
      <doc xml:space="preserve">The name of the templates for the source pad.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DEF_CHANNELS"
              value="2"
              c:type="GST_AUDIO_DEF_CHANNELS">
      <doc xml:space="preserve">Standard number of channels used in consumer audio.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_DEF_FORMAT"
              value="S16LE"
              c:type="GST_AUDIO_DEF_FORMAT">
      <doc xml:space="preserve">Standard format used in consumer audio.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_DEF_RATE" value="44100" c:type="GST_AUDIO_DEF_RATE">
      <doc xml:space="preserve">Standard sampling rate used in consumer audio.</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_ENCODER_SINK_NAME"
              value="sink"
              c:type="GST_AUDIO_ENCODER_SINK_NAME">
      <doc xml:space="preserve">the name of the templates for the sink pad</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_ENCODER_SRC_NAME"
              value="src"
              c:type="GST_AUDIO_ENCODER_SRC_NAME">
      <doc xml:space="preserve">the name of the templates for the source pad</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_FORMATS_ALL"
              value=" { S8, U8, S16LE, S16BE, U16LE, U16BE, S24_32LE, S24_32BE, U24_32LE, U24_32BE, S32LE, S32BE, U32LE, U32BE, S24LE, S24BE, U24LE, U24BE, S20LE, S20BE, U20LE, U20BE, S18LE, S18BE, U18LE, U18BE, F32LE, F32BE, F64LE, F64BE }"
              c:type="GST_AUDIO_FORMATS_ALL">
      <doc xml:space="preserve">List of all audio formats, for use in template caps strings.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RATE_RANGE"
              value="(int) [ 1, max ]"
              c:type="GST_AUDIO_RATE_RANGE">
      <doc xml:space="preserve">Maximum range of allowed sample rates, for use in template caps strings.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_CUBIC_B"
              value="GstAudioResampler.cubic-b"
              c:type="GST_AUDIO_RESAMPLER_OPT_CUBIC_B">
      <doc xml:space="preserve">G_TYPE_DOUBLE, B parameter of the cubic filter.
Values between 0.0 and 2.0 are accepted. 1.0 is the default.

Below are some values of popular filters:
                   B       C
Hermite           0.0     0.0
Spline            1.0     0.0
Catmull-Rom       0.0     1/2</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_CUBIC_C"
              value="GstAudioResampler.cubic-c"
              c:type="GST_AUDIO_RESAMPLER_OPT_CUBIC_C">
      <doc xml:space="preserve">G_TYPE_DOUBLE, C parameter of the cubic filter.
Values between 0.0 and 2.0 are accepted. 0.0 is the default.

See #GST_AUDIO_RESAMPLER_OPT_CUBIC_B for some more common values</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_CUTOFF"
              value="GstAudioResampler.cutoff"
              c:type="GST_AUDIO_RESAMPLER_OPT_CUTOFF">
      <doc xml:space="preserve">G_TYPE_DOUBLE, Cutoff parameter for the filter. 0.940 is the default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_FILTER_INTERPOLATION"
              value="GstAudioResampler.filter-interpolation"
              c:type="GST_AUDIO_RESAMPLER_OPT_FILTER_INTERPOLATION">
      <doc xml:space="preserve">GST_TYPE_AUDIO_RESAMPLER_INTERPOLATION: how the filter coeficients should be
   interpolated.
GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC is default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_FILTER_MODE"
              value="GstAudioResampler.filter-mode"
              c:type="GST_AUDIO_RESAMPLER_OPT_FILTER_MODE">
      <doc xml:space="preserve">GST_TYPE_AUDIO_RESAMPLER_FILTER_MODE: how the filter tables should be
constructed.
GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO is the default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_FILTER_MODE_THRESHOLD"
              value="GstAudioResampler.filter-mode-threshold"
              c:type="GST_AUDIO_RESAMPLER_OPT_FILTER_MODE_THRESHOLD">
      <doc xml:space="preserve">G_TYPE_UINT: the amount of memory to use for full filter tables before
switching to interpolated filter tables.
1048576 is the default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE"
              value="GstAudioResampler.filter-oversample"
              c:type="GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE">
      <doc xml:space="preserve">G_TYPE_UINT, oversampling to use when interpolating filters
8 is the default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_MAX_PHASE_ERROR"
              value="GstAudioResampler.max-phase-error"
              c:type="GST_AUDIO_RESAMPLER_OPT_MAX_PHASE_ERROR">
      <doc xml:space="preserve">G_TYPE_DOUBLE: The maximum allowed phase error when switching sample
rates.
0.1 is the default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_N_TAPS"
              value="GstAudioResampler.n-taps"
              c:type="GST_AUDIO_RESAMPLER_OPT_N_TAPS">
      <doc xml:space="preserve">G_TYPE_INT: the number of taps to use for the filter.
0 is the default and selects the taps automatically.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_STOP_ATTENUATION"
              value="GstAudioResampler.stop-attenutation"
              c:type="GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION">
      <doc xml:space="preserve">G_TYPE_DOUBLE, stopband attenuation in decibels. The attenuation
after the stopband for the kaiser window. 85 dB is the default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH"
              value="GstAudioResampler.transition-bandwidth"
              c:type="GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH">
      <doc xml:space="preserve">G_TYPE_DOUBLE, transition bandwidth. The width of the
transition band for the kaiser window. 0.087 is the default.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_QUALITY_DEFAULT"
              value="4"
              c:type="GST_AUDIO_RESAMPLER_QUALITY_DEFAULT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_QUALITY_MAX"
              value="10"
              c:type="GST_AUDIO_RESAMPLER_QUALITY_MAX">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="AUDIO_RESAMPLER_QUALITY_MIN"
              value="0"
              c:type="GST_AUDIO_RESAMPLER_QUALITY_MIN">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="AudioAggregator"
           c:symbol-prefix="audio_aggregator"
           c:type="GstAudioAggregator"
           parent="GstBase.Aggregator"
           abstract="1"
           glib:type-name="GstAudioAggregator"
           glib:get-type="gst_audio_aggregator_get_type"
           glib:type-struct="AudioAggregatorClass">
      <doc xml:space="preserve">Subclasses must use (a subclass of) #GstAudioAggregatorPad for both
their source and sink pads,
gst_element_class_add_static_pad_template_with_gtype() is a convenient
helper.

#GstAudioAggregator can perform conversion on the data arriving
on its sink pads, based on the format expected downstream: in order
to enable that behaviour, the GType of the sink pads must either be
a (subclass of) #GstAudioAggregatorConvertPad to use the default
#GstAudioConverter implementation, or a subclass of #GstAudioAggregatorPad
implementing #GstAudioAggregatorPad.convert_buffer.

To allow for the output caps to change, the mechanism is the same as
above, with the GType of the source pad.

See #GstAudioMixer for an example.

When conversion is enabled, #GstAudioAggregator will accept
any type of raw audio caps and perform conversion
on the data arriving on its sink pads, with whatever downstream
expects as the target format.

In case downstream caps are not fully fixated, it will use
the first configured sink pad to finish fixating its source pad
caps.

A notable exception for now is the sample rate, sink pads must
have the same sample rate as either the downstream requirement,
or the first configured pad, or a combination of both (when
downstream specifies a range or a set of acceptable rates).</doc>
      <virtual-method name="aggregate_one_buffer">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aagg" transfer-ownership="none">
            <type name="AudioAggregator" c:type="GstAudioAggregator*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad*"/>
          </parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="in_offset" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="out_offset" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="num_frames" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_output_buffer">
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="aagg" transfer-ownership="none">
            <type name="AudioAggregator" c:type="GstAudioAggregator*"/>
          </instance-parameter>
          <parameter name="num_frames" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="set_sink_caps"
              c:identifier="gst_audio_aggregator_set_sink_caps">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="aagg" transfer-ownership="none">
            <type name="AudioAggregator" c:type="GstAudioAggregator*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <property name="alignment-threshold"
                writable="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="discont-wait" writable="1" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="output-buffer-duration"
                writable="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <field name="parent">
        <doc xml:space="preserve">The parent #GstAggregator</doc>
        <type name="GstBase.Aggregator" c:type="GstAggregator"/>
      </field>
      <field name="current_caps">
        <doc xml:space="preserve">The caps set by the subclass</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioAggregatorPrivate"
              c:type="GstAudioAggregatorPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioAggregatorClass"
            c:type="GstAudioAggregatorClass"
            glib:is-gtype-struct-for="AudioAggregator">
      <field name="parent_class">
        <type name="GstBase.AggregatorClass" c:type="GstAggregatorClass"/>
      </field>
      <field name="create_output_buffer">
        <callback name="create_output_buffer">
          <return-value transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="aagg" transfer-ownership="none">
              <type name="AudioAggregator" c:type="GstAudioAggregator*"/>
            </parameter>
            <parameter name="num_frames" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="aggregate_one_buffer">
        <callback name="aggregate_one_buffer">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aagg" transfer-ownership="none">
              <type name="AudioAggregator" c:type="GstAudioAggregator*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="in_offset" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="out_offset" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="num_frames" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AudioAggregatorConvertPad"
           c:symbol-prefix="audio_aggregator_convert_pad"
           c:type="GstAudioAggregatorConvertPad"
           parent="AudioAggregatorPad"
           glib:type-name="GstAudioAggregatorConvertPad"
           glib:get-type="gst_audio_aggregator_convert_pad_get_type"
           glib:type-struct="AudioAggregatorConvertPadClass">
      <doc xml:space="preserve">An implementation of GstPad that can be used with #GstAudioAggregator.

See #GstAudioAggregator for more details.</doc>
      <property name="converter-config" writable="1" transfer-ownership="none">
        <type name="Gst.Structure"/>
      </property>
      <field name="parent">
        <doc xml:space="preserve">The parent #GstAudioAggregatorPad</doc>
        <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioAggregatorConvertPadPrivate"
              c:type="GstAudioAggregatorConvertPadPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioAggregatorConvertPadClass"
            c:type="GstAudioAggregatorConvertPadClass"
            glib:is-gtype-struct-for="AudioAggregatorConvertPad">
      <field name="parent_class">
        <type name="AudioAggregatorPadClass"
              c:type="GstAudioAggregatorPadClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioAggregatorConvertPadPrivate"
            c:type="GstAudioAggregatorConvertPadPrivate"
            disguised="1">
    </record>
    <class name="AudioAggregatorPad"
           c:symbol-prefix="audio_aggregator_pad"
           c:type="GstAudioAggregatorPad"
           parent="GstBase.AggregatorPad"
           glib:type-name="GstAudioAggregatorPad"
           glib:get-type="gst_audio_aggregator_pad_get_type"
           glib:type-struct="AudioAggregatorPadClass">
      <doc xml:space="preserve">The default implementation of GstPad used with #GstAudioAggregator</doc>
      <virtual-method name="convert_buffer">
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad*"/>
          </instance-parameter>
          <parameter name="in_info" transfer-ownership="none">
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </parameter>
          <parameter name="out_info" transfer-ownership="none">
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_conversion_info">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <field name="parent">
        <doc xml:space="preserve">The parent #GstAggregatorPad</doc>
        <type name="GstBase.AggregatorPad" c:type="GstAggregatorPad"/>
      </field>
      <field name="info">
        <doc xml:space="preserve">The audio info for this pad set from the incoming caps</doc>
        <type name="AudioInfo" c:type="GstAudioInfo"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioAggregatorPadPrivate"
              c:type="GstAudioAggregatorPadPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioAggregatorPadClass"
            c:type="GstAudioAggregatorPadClass"
            glib:is-gtype-struct-for="AudioAggregatorPad">
      <field name="parent_class">
        <type name="GstBase.AggregatorPadClass"
              c:type="GstAggregatorPadClass"/>
      </field>
      <field name="convert_buffer">
        <callback name="convert_buffer">
          <return-value transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad*"/>
            </parameter>
            <parameter name="in_info" transfer-ownership="none">
              <type name="AudioInfo" c:type="GstAudioInfo*"/>
            </parameter>
            <parameter name="out_info" transfer-ownership="none">
              <type name="AudioInfo" c:type="GstAudioInfo*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="update_conversion_info">
        <callback name="update_conversion_info">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pad" transfer-ownership="none">
              <type name="AudioAggregatorPad" c:type="GstAudioAggregatorPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioAggregatorPadPrivate"
            c:type="GstAudioAggregatorPadPrivate"
            disguised="1">
    </record>
    <record name="AudioAggregatorPrivate"
            c:type="GstAudioAggregatorPrivate"
            disguised="1">
    </record>
    <class name="AudioBaseSink"
           c:symbol-prefix="audio_base_sink"
           c:type="GstAudioBaseSink"
           parent="GstBase.BaseSink"
           glib:type-name="GstAudioBaseSink"
           glib:get-type="gst_audio_base_sink_get_type"
           glib:type-struct="AudioBaseSinkClass">
      <doc xml:space="preserve">This is the base class for audio sinks. Subclasses need to implement the
::create_ringbuffer vmethod. This base class will then take care of
writing samples to the ringbuffer, synchronisation, clipping and flushing.</doc>
      <virtual-method name="create_ringbuffer" invoker="create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @sink. This function will
call the ::create_ringbuffer vmethod and will set @sink as the parent of
the returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @sink.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink.</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="payload">
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_audio_base_sink_create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @sink. This function will
call the ::create_ringbuffer vmethod and will set @sink as the parent of
the returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @sink.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink.</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alignment_threshold"
              c:identifier="gst_audio_base_sink_get_alignment_threshold">
        <doc xml:space="preserve">Get the current alignment threshold, in nanoseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current alignment threshold used by @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_discont_wait"
              c:identifier="gst_audio_base_sink_get_discont_wait">
        <doc xml:space="preserve">Get the current discont wait, in nanoseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current discont wait used by @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drift_tolerance"
              c:identifier="gst_audio_base_sink_get_drift_tolerance">
        <doc xml:space="preserve">Get the current drift tolerance, in microseconds, used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current drift tolerance used by @sink.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_audio_base_sink_get_provide_clock">
        <doc xml:space="preserve">Queries whether @sink will provide a clock or not. See also
gst_audio_base_sink_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @sink will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_audio_base_sink_get_slave_method">
        <doc xml:space="preserve">Get the current slave method used by @sink.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current slave method used by @sink.</doc>
          <type name="AudioBaseSinkSlaveMethod"
                c:type="GstAudioBaseSinkSlaveMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="report_device_failure"
              c:identifier="gst_audio_base_sink_report_device_failure"
              version="1.6">
        <doc xml:space="preserve">Informs this base class that the audio output device has failed for
some reason, causing a discontinuity (for example, because the device
recovered from the error, but lost all contents of its ring buffer).
This function is typically called by derived classes, and is useful
for the custom slave method.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_alignment_threshold"
              c:identifier="gst_audio_base_sink_set_alignment_threshold">
        <doc xml:space="preserve">Controls the sink's alignment threshold.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="alignment_threshold" transfer-ownership="none">
            <doc xml:space="preserve">the new alignment threshold in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_custom_slaving_callback"
              c:identifier="gst_audio_base_sink_set_custom_slaving_callback"
              version="1.6">
        <doc xml:space="preserve">Sets the custom slaving callback. This callback will
be invoked if the slave-method property is set to
GST_AUDIO_BASE_SINK_SLAVE_CUSTOM and the audio sink
receives and plays samples.

Setting the callback to NULL causes the sink to
behave as if the GST_AUDIO_BASE_SINK_SLAVE_NONE
method were used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">a #GstAudioBaseSinkCustomSlavingCallback</doc>
            <type name="AudioBaseSinkCustomSlavingCallback"
                  c:type="GstAudioBaseSinkCustomSlavingCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">called when user_data becomes unused</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_discont_wait"
              c:identifier="gst_audio_base_sink_set_discont_wait">
        <doc xml:space="preserve">Controls how long the sink will wait before creating a discontinuity.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="discont_wait" transfer-ownership="none">
            <doc xml:space="preserve">the new discont wait in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drift_tolerance"
              c:identifier="gst_audio_base_sink_set_drift_tolerance">
        <doc xml:space="preserve">Controls the sink's drift tolerance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="drift_tolerance" transfer-ownership="none">
            <doc xml:space="preserve">the new drift tolerance in microseconds</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_audio_base_sink_set_provide_clock">
        <doc xml:space="preserve">Controls whether @sink will provide a clock or not. If @provide is %TRUE,
gst_element_provide_clock() will return a clock that reflects the datarate
of @sink. If @provide is %FALSE, gst_element_provide_clock() will return
NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_audio_base_sink_set_slave_method">
        <doc xml:space="preserve">Controls how clock slaving will be performed in @sink.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSink</doc>
            <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the new slave method</doc>
            <type name="AudioBaseSinkSlaveMethod"
                  c:type="GstAudioBaseSinkSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="alignment-threshold"
                writable="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="can-activate-pull"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="discont-wait" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A window of time in nanoseconds to wait before creating a discontinuity as
a result of breaching the drift-tolerance.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="drift-tolerance" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Controls the amount of time in microseconds that clocks are allowed
to drift before resynchronisation happens.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="AudioBaseSinkSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.BaseSink" c:type="GstBaseSink"/>
      </field>
      <field name="ringbuffer">
        <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="latency_time">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="provided_clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="eos_rendering">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioBaseSinkPrivate" c:type="GstAudioBaseSinkPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioBaseSinkClass"
            c:type="GstAudioBaseSinkClass"
            glib:is-gtype-struct-for="AudioBaseSink">
      <doc xml:space="preserve">#GstAudioBaseSink class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class.</doc>
        <type name="GstBase.BaseSinkClass" c:type="GstBaseSinkClass"/>
      </field>
      <field name="create_ringbuffer">
        <callback name="create_ringbuffer">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The new ringbuffer of @sink.</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioBaseSink.</doc>
              <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="payload">
        <callback name="payload">
          <return-value transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioBaseSinkCustomSlavingCallback"
              c:type="GstAudioBaseSinkCustomSlavingCallback"
              version="1.6">
      <doc xml:space="preserve">This function is set with gst_audio_base_sink_set_custom_slaving_callback()
and is called during playback. It receives the current time of external and
internal clocks, which the callback can then use to apply any custom
slaving/synchronization schemes.

The external clock is the sink's element clock, the internal one is the
internal audio clock. The internal audio clock's calibration is applied to
the timestamps before they are passed to the callback. The difference between
etime and itime is the skew; how much internal and external clock lie apart
from each other. A skew of 0 means both clocks are perfectly in sync.
itime &gt; etime means the external clock is going slower, while itime &lt; etime
means it is going faster than the internal clock. etime and itime are always
valid timestamps, except for when a discontinuity happens.

requested_skew is an output value the callback can write to. It informs the
sink of whether or not it should move the playout pointer, and if so, by how
much. This pointer is only NULL if a discontinuity occurs; otherwise, it is
safe to write to *requested_skew. The default skew is 0.

The sink may experience discontinuities. If one happens, discont is TRUE,
itime, etime are set to GST_CLOCK_TIME_NONE, and requested_skew is NULL.
This makes it possible to reset custom clock slaving algorithms when a
discontinuity happens.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="sink" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioBaseSink</doc>
          <type name="AudioBaseSink" c:type="GstAudioBaseSink*"/>
        </parameter>
        <parameter name="etime" transfer-ownership="none">
          <doc xml:space="preserve">external clock time</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="itime" transfer-ownership="none">
          <doc xml:space="preserve">internal clock time</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="requested_skew" transfer-ownership="none">
          <doc xml:space="preserve">skew amount requested by the callback</doc>
          <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
        </parameter>
        <parameter name="discont_reason" transfer-ownership="none">
          <doc xml:space="preserve">reason for discontinuity (if any)</doc>
          <type name="AudioBaseSinkDiscontReason"
                c:type="GstAudioBaseSinkDiscontReason"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="5">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="AudioBaseSinkDiscontReason"
                 version="1.6"
                 glib:type-name="GstAudioBaseSinkDiscontReason"
                 glib:get-type="gst_audio_base_sink_discont_reason_get_type"
                 c:type="GstAudioBaseSinkDiscontReason">
      <doc xml:space="preserve">Different possible reasons for discontinuities. This enum is useful for the custom
slave method.</doc>
      <member name="no_discont"
              value="0"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_NO_DISCONT"
              glib:nick="no-discont">
        <doc xml:space="preserve">No discontinuity occurred</doc>
      </member>
      <member name="new_caps"
              value="1"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS"
              glib:nick="new-caps">
        <doc xml:space="preserve">New caps are set, causing renegotiotion</doc>
      </member>
      <member name="flush"
              value="2"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH"
              glib:nick="flush">
        <doc xml:space="preserve">Samples have been flushed</doc>
      </member>
      <member name="sync_latency"
              value="3"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY"
              glib:nick="sync-latency">
        <doc xml:space="preserve">Sink was synchronized to the estimated latency (occurs during initialization)</doc>
      </member>
      <member name="alignment"
              value="4"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT"
              glib:nick="alignment">
        <doc xml:space="preserve">Aligning buffers failed because the timestamps are too discontinuous</doc>
      </member>
      <member name="device_failure"
              value="5"
              c:identifier="GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE"
              glib:nick="device-failure">
        <doc xml:space="preserve">Audio output device experienced and recovered from an error but introduced latency in the process (see also @gst_audio_base_sink_report_device_failure())</doc>
      </member>
    </enumeration>
    <record name="AudioBaseSinkPrivate"
            c:type="GstAudioBaseSinkPrivate"
            disguised="1">
    </record>
    <enumeration name="AudioBaseSinkSlaveMethod"
                 glib:type-name="GstAudioBaseSinkSlaveMethod"
                 glib:get-type="gst_audio_base_sink_slave_method_get_type"
                 c:type="GstAudioBaseSinkSlaveMethod">
      <doc xml:space="preserve">Different possible clock slaving algorithms used when the internal audio
clock is not selected as the pipeline master clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE"
              glib:nick="resample">
        <doc xml:space="preserve">Resample to match the master clock</doc>
      </member>
      <member name="skew"
              value="1"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_SKEW"
              glib:nick="skew">
        <doc xml:space="preserve">Adjust playout pointer when master clock
drifts too much.</doc>
      </member>
      <member name="none"
              value="2"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No adjustment is done.</doc>
      </member>
      <member name="custom"
              value="3"
              c:identifier="GST_AUDIO_BASE_SINK_SLAVE_CUSTOM"
              glib:nick="custom">
        <doc xml:space="preserve">Use custom clock slaving algorithm (Since: 1.6)</doc>
      </member>
    </enumeration>
    <class name="AudioBaseSrc"
           c:symbol-prefix="audio_base_src"
           c:type="GstAudioBaseSrc"
           parent="GstBase.PushSrc"
           glib:type-name="GstAudioBaseSrc"
           glib:get-type="gst_audio_base_src_get_type"
           glib:type-struct="AudioBaseSrcClass">
      <doc xml:space="preserve">This is the base class for audio sources. Subclasses need to implement the
::create_ringbuffer vmethod. This base class will then take care of
reading samples from the ringbuffer, synchronisation and flushing.</doc>
      <virtual-method name="create_ringbuffer" invoker="create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @src. This function will call
the ::create_ringbuffer vmethod and will set @src as the parent of the
returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @src.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc.</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="create_ringbuffer"
              c:identifier="gst_audio_base_src_create_ringbuffer">
        <doc xml:space="preserve">Create and return the #GstAudioRingBuffer for @src. This function will call
the ::create_ringbuffer vmethod and will set @src as the parent of the
returned buffer (see gst_object_set_parent()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The new ringbuffer of @src.</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc.</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_provide_clock"
              c:identifier="gst_audio_base_src_get_provide_clock">
        <doc xml:space="preserve">Queries whether @src will provide a clock or not. See also
gst_audio_base_src_set_provide_clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @src will provide a clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_slave_method"
              c:identifier="gst_audio_base_src_get_slave_method">
        <doc xml:space="preserve">Get the current slave method used by @src.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current slave method used by @src.</doc>
          <type name="AudioBaseSrcSlaveMethod"
                c:type="GstAudioBaseSrcSlaveMethod"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_provide_clock"
              c:identifier="gst_audio_base_src_set_provide_clock">
        <doc xml:space="preserve">Controls whether @src will provide a clock or not. If @provide is %TRUE,
gst_element_provide_clock() will return a clock that reflects the datarate
of @src. If @provide is %FALSE, gst_element_provide_clock() will return NULL.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
          <parameter name="provide" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_slave_method"
              c:identifier="gst_audio_base_src_set_slave_method">
        <doc xml:space="preserve">Controls how clock slaving will be performed in @src.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioBaseSrc</doc>
            <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
          </instance-parameter>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">the new slave method</doc>
            <type name="AudioBaseSrcSlaveMethod"
                  c:type="GstAudioBaseSrcSlaveMethod"/>
          </parameter>
        </parameters>
      </method>
      <property name="actual-buffer-time" transfer-ownership="none">
        <doc xml:space="preserve">Actual configured size of audio buffer in microseconds.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="actual-latency-time" transfer-ownership="none">
        <doc xml:space="preserve">Actual configured audio latency in microseconds.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="buffer-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="latency-time" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="provide-clock" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="slave-method" writable="1" transfer-ownership="none">
        <type name="AudioBaseSrcSlaveMethod"/>
      </property>
      <field name="element">
        <type name="GstBase.PushSrc" c:type="GstPushSrc"/>
      </field>
      <field name="ringbuffer">
        <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
      </field>
      <field name="buffer_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="latency_time">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="next_sample">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="clock">
        <type name="Gst.Clock" c:type="GstClock*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioBaseSrcPrivate" c:type="GstAudioBaseSrcPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioBaseSrcClass"
            c:type="GstAudioBaseSrcClass"
            glib:is-gtype-struct-for="AudioBaseSrc">
      <doc xml:space="preserve">#GstAudioBaseSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class.</doc>
        <type name="GstBase.PushSrcClass" c:type="GstPushSrcClass"/>
      </field>
      <field name="create_ringbuffer">
        <callback name="create_ringbuffer">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The new ringbuffer of @src.</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioBaseSrc.</doc>
              <type name="AudioBaseSrc" c:type="GstAudioBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioBaseSrcPrivate"
            c:type="GstAudioBaseSrcPrivate"
            disguised="1">
    </record>
    <enumeration name="AudioBaseSrcSlaveMethod"
                 glib:type-name="GstAudioBaseSrcSlaveMethod"
                 glib:get-type="gst_audio_base_src_slave_method_get_type"
                 c:type="GstAudioBaseSrcSlaveMethod">
      <doc xml:space="preserve">Different possible clock slaving algorithms when the internal audio clock was
not selected as the pipeline clock.</doc>
      <member name="resample"
              value="0"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_RESAMPLE"
              glib:nick="resample">
        <doc xml:space="preserve">Resample to match the master clock.</doc>
      </member>
      <member name="re_timestamp"
              value="1"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_RE_TIMESTAMP"
              glib:nick="re-timestamp">
        <doc xml:space="preserve">Retimestamp output buffers with master
clock time.</doc>
      </member>
      <member name="skew"
              value="2"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_SKEW"
              glib:nick="skew">
        <doc xml:space="preserve">Adjust capture pointer when master clock
drifts too much.</doc>
      </member>
      <member name="none"
              value="3"
              c:identifier="GST_AUDIO_BASE_SRC_SLAVE_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No adjustment is done.</doc>
      </member>
    </enumeration>
    <class name="AudioCdSrc"
           c:symbol-prefix="audio_cd_src"
           c:type="GstAudioCdSrc"
           parent="GstBase.PushSrc"
           glib:type-name="GstAudioCdSrc"
           glib:get-type="gst_audio_cd_src_get_type"
           glib:type-struct="AudioCdSrcClass">
      <doc xml:space="preserve">Provides a base class for CD digital audio (CDDA) sources, which handles
things like seeking, querying, discid calculation, tags, and buffer
timestamping.

## Using GstAudioCdSrc-based elements in applications

GstAudioCdSrc registers two #GstFormat&lt;!-- --&gt;s of its own, namely
the "track" format and the "sector" format. Applications will usually
only find the "track" format interesting. You can retrieve that #GstFormat
for use in seek events or queries with gst_format_get_by_nick("track").

In order to query the number of tracks, for example, an application would
set the CDDA source element to READY or PAUSED state and then query the
the number of tracks via gst_element_query_duration() using the track
format acquired above. Applications can query the currently playing track
in the same way.

Alternatively, applications may retrieve the currently playing track and
the total number of tracks from the taglist that will posted on the bus
whenever the CD is opened or the currently playing track changes. The
taglist will contain GST_TAG_TRACK_NUMBER and GST_TAG_TRACK_COUNT tags.

Applications playing back CD audio using playbin and cdda://n URIs should
issue a seek command in track format to change between tracks, rather than
setting a new cdda://n+1 URI on playbin (as setting a new URI on playbin
involves closing and re-opening the CD device, which is much much slower).

## Tags and meta-information

CDDA sources will automatically emit a number of tags, details about which
can be found in the libgsttag documentation. Those tags are:
#GST_TAG_CDDA_CDDB_DISCID, #GST_TAG_CDDA_CDDB_DISCID_FULL,
#GST_TAG_CDDA_MUSICBRAINZ_DISCID, #GST_TAG_CDDA_MUSICBRAINZ_DISCID_FULL,
among others.

## Tracks and Table of Contents (TOC)

Applications will be informed of the available tracks via a TOC message
on the pipeline's #GstBus. The #GstToc will contain a #GstTocEntry for
each track, with information about each track. The duration for each
track can be retrieved via the #GST_TAG_DURATION tag from each entry's
tag list, or calculated via gst_toc_entry_get_start_stop_times().
The track entries in the TOC will be sorted by track number.</doc>
      <implements name="Gst.URIHandler"/>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
          <parameter name="device" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read_sector">
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
          <parameter name="sector" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_track" c:identifier="gst_audio_cd_src_add_track">
        <doc xml:space="preserve">CDDA sources use this function from their start vfunc to announce the
available data and audio tracks to the base source class. The caller
should allocate @track on the stack, the base source will do a shallow
copy of the structure (and take ownership of the taglist if there is one).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">FALSE on error, otherwise TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioCdSrc</doc>
            <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
          </instance-parameter>
          <parameter name="track" transfer-ownership="none">
            <doc xml:space="preserve">address of #GstAudioCdSrcTrack to add</doc>
            <type name="AudioCdSrcTrack" c:type="GstAudioCdSrcTrack*"/>
          </parameter>
        </parameters>
      </method>
      <property name="device" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="mode" writable="1" transfer-ownership="none">
        <type name="AudioCdSrcMode"/>
      </property>
      <property name="track" writable="1" transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="pushsrc">
        <type name="GstBase.PushSrc" c:type="GstPushSrc"/>
      </field>
      <field name="tags">
        <type name="Gst.TagList" c:type="GstTagList*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioCdSrcPrivate" c:type="GstAudioCdSrcPrivate*"/>
      </field>
      <field name="_gst_reserved1" readable="0" private="1">
        <array zero-terminated="0" c:type="guint" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="_gst_reserved2" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioCdSrcClass"
            c:type="GstAudioCdSrcClass"
            glib:is-gtype-struct-for="AudioCdSrc">
      <doc xml:space="preserve">Audio CD source base class.</doc>
      <field name="pushsrc_class">
        <doc xml:space="preserve">the parent class</doc>
        <type name="GstBase.PushSrcClass" c:type="GstPushSrcClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
            </parameter>
            <parameter name="device" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read_sector">
        <callback name="read_sector">
          <return-value transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioCdSrc" c:type="GstAudioCdSrc*"/>
            </parameter>
            <parameter name="sector" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="AudioCdSrcMode"
                 glib:type-name="GstAudioCdSrcMode"
                 glib:get-type="gst_audio_cd_src_mode_get_type"
                 c:type="GstAudioCdSrcMode">
      <doc xml:space="preserve">Mode in which the CD audio source operates. Influences timestamping,
EOS handling and seeking.</doc>
      <member name="normal"
              value="0"
              c:identifier="GST_AUDIO_CD_SRC_MODE_NORMAL"
              glib:nick="normal">
        <doc xml:space="preserve">each single track is a stream</doc>
      </member>
      <member name="continuous"
              value="1"
              c:identifier="GST_AUDIO_CD_SRC_MODE_CONTINUOUS"
              glib:nick="continuous">
        <doc xml:space="preserve">the entire disc is a single stream</doc>
      </member>
    </enumeration>
    <record name="AudioCdSrcPrivate"
            c:type="GstAudioCdSrcPrivate"
            disguised="1">
    </record>
    <record name="AudioCdSrcTrack" c:type="GstAudioCdSrcTrack">
      <doc xml:space="preserve">CD track abstraction to communicate TOC entries to the base class.

This structure is only for use by sub-classed in connection with
gst_audio_cd_src_add_track().

Applications will be informed of the available tracks via a TOC message
on the pipeline's #GstBus instead.</doc>
      <field name="is_audio" writable="1">
        <doc xml:space="preserve">Whether this is an audio track</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="num" writable="1">
        <doc xml:space="preserve">Track number in TOC (usually starts from 1, but not always)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="start" writable="1">
        <doc xml:space="preserve">The first sector of this track (LBA)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="end" writable="1">
        <doc xml:space="preserve">The last sector of this track (LBA)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="tags" writable="1">
        <doc xml:space="preserve">Track-specific tags (e.g. from cd-text information), or NULL</doc>
        <type name="Gst.TagList" c:type="GstTagList*"/>
      </field>
      <field name="_gst_reserved1" readable="0" private="1">
        <array zero-terminated="0" c:type="guint" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="_gst_reserved2" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioChannelMixer"
            c:type="GstAudioChannelMixer"
            disguised="1">
      <method name="free" c:identifier="gst_audio_channel_mixer_free">
        <doc xml:space="preserve">Free memory allocated by @mix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mix" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioChannelMixer</doc>
            <type name="AudioChannelMixer" c:type="GstAudioChannelMixer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_passthrough"
              c:identifier="gst_audio_channel_mixer_is_passthrough">
        <doc xml:space="preserve">Check if @mix is in passthrough.

Only N x N mix identity matrices are considered passthrough,
this is determined by comparing the contents of the matrix
with 0.0 and 1.0.

As this is floating point comparisons, if the values have been
generated, they should be rounded up or down by explicit
assignment of 0.0 or 1.0 to values within a user-defined
epsilon, this code doesn't make assumptions as to what may
constitute an appropriate epsilon.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is @mix is passthrough.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="mix" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioChannelMixer</doc>
            <type name="AudioChannelMixer" c:type="GstAudioChannelMixer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="samples" c:identifier="gst_audio_channel_mixer_samples">
        <doc xml:space="preserve">In case the samples are interleaved, @in and @out must point to an
array with a single element pointing to a block of interleaved samples.

If non-interleaved samples are used, @in and @out must point to an
array with pointers to memory blocks, one for each channel.

Perform channel mixing on @in_data and write the result to @out_data.
@in_data and @out_data need to be in @format and @layout.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="mix" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioChannelMixer</doc>
            <type name="AudioChannelMixer" c:type="GstAudioChannelMixer*"/>
          </instance-parameter>
          <parameter name="in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">input samples</doc>
            <type name="gpointer" c:type="const gpointer"/>
          </parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">output samples</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="samples" transfer-ownership="none">
            <doc xml:space="preserve">number of samples</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_audio_channel_mixer_new"
                introspectable="0">
        <doc xml:space="preserve">Create a new channel mixer object for the given parameters.</doc>
        <return-value>
          <doc xml:space="preserve">a new #GstAudioChannelMixer object, or %NULL if @format isn't supported.
  Free with gst_audio_channel_mixer_free() after usage.</doc>
          <type name="AudioChannelMixer" c:type="GstAudioChannelMixer*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GstAudioChannelMixerFlags</doc>
            <type name="AudioChannelMixerFlags"
                  c:type="GstAudioChannelMixerFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
          <parameter name="in_channels" transfer-ownership="none">
            <doc xml:space="preserve">number of input channels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="in_position" transfer-ownership="none">
            <doc xml:space="preserve">positions of input channels</doc>
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition*"/>
          </parameter>
          <parameter name="out_channels" transfer-ownership="none">
            <doc xml:space="preserve">number of output channels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_position" transfer-ownership="none">
            <doc xml:space="preserve">positions of output channels</doc>
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_matrix"
                c:identifier="gst_audio_channel_mixer_new_with_matrix"
                version="1.14"
                introspectable="0">
        <doc xml:space="preserve">Create a new channel mixer object for the given parameters.</doc>
        <return-value>
          <doc xml:space="preserve">a new #GstAudioChannelMixer object, or %NULL if @format isn't supported,
  @matrix is invalid, or @matrix is %NULL and @in_channels != @out_channels.
  Free with gst_audio_channel_mixer_free() after usage.</doc>
          <type name="AudioChannelMixer" c:type="GstAudioChannelMixer*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GstAudioChannelMixerFlags</doc>
            <type name="AudioChannelMixerFlags"
                  c:type="GstAudioChannelMixerFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
          <parameter name="in_channels" transfer-ownership="none">
            <doc xml:space="preserve">number of input channels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_channels" transfer-ownership="none">
            <doc xml:space="preserve">number of output channels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="matrix"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">channel conversion matrix, m[@in_channels][@out_channels].
  If identity matrix, passthrough applies. If %NULL, a (potentially truncated)
  identity matrix is generated.</doc>
            <type name="gfloat" c:type="gfloat**"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="AudioChannelMixerFlags"
              glib:type-name="GstAudioChannelMixerFlags"
              glib:get-type="gst_audio_channel_mixer_flags_get_type"
              c:type="GstAudioChannelMixerFlags">
      <doc xml:space="preserve">Flags passed to gst_audio_channel_mixer_new()</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_CHANNEL_MIXER_FLAGS_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flag</doc>
      </member>
      <member name="non_interleaved_in"
              value="1"
              c:identifier="GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_IN"
              glib:nick="non-interleaved-in">
        <doc xml:space="preserve">input channels are not interleaved</doc>
      </member>
      <member name="non_interleaved_out"
              value="2"
              c:identifier="GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_OUT"
              glib:nick="non-interleaved-out">
        <doc xml:space="preserve">output channels are not interleaved</doc>
      </member>
      <member name="unpositioned_in"
              value="4"
              c:identifier="GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN"
              glib:nick="unpositioned-in">
        <doc xml:space="preserve">input channels are explicitly unpositioned</doc>
      </member>
      <member name="unpositioned_out"
              value="8"
              c:identifier="GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_OUT"
              glib:nick="unpositioned-out">
        <doc xml:space="preserve">output channels are explicitly unpositioned</doc>
      </member>
    </bitfield>
    <enumeration name="AudioChannelPosition"
                 glib:type-name="GstAudioChannelPosition"
                 glib:get-type="gst_audio_channel_position_get_type"
                 c:type="GstAudioChannelPosition">
      <doc xml:space="preserve">Audio channel positions.

These are the channels defined in SMPTE 2036-2-2008
Table 1 for 22.2 audio systems with the Surround and Wide channels from
DTS Coherent Acoustics (v.1.3.1) and 10.2 and 7.1 layouts. In the caps the
actual channel layout is expressed with a channel count and a channel mask,
which describes the existing channels. The positions in the bit mask correspond
to the enum values.
For negotiation it is allowed to have more bits set in the channel mask than
the number of channels to specify the allowed channel positions but this is
not allowed in negotiated caps. It is not allowed in any situation other
than the one mentioned below to have less bits set in the channel mask than
the number of channels.

@GST_AUDIO_CHANNEL_POSITION_MONO can only be used with a single mono channel that
has no direction information and would be mixed into all directional channels.
This is expressed in caps by having a single channel and no channel mask.

@GST_AUDIO_CHANNEL_POSITION_NONE can only be used if all channels have this position.
This is expressed in caps by having a channel mask with no bits set.

As another special case it is allowed to have two channels without a channel mask.
This implicitely means that this is a stereo stream with a front left and front right
channel.</doc>
      <member name="none"
              value="-3"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">used for position-less channels, e.g.
    from a sound card that records 1024 channels; mutually exclusive with
    any other channel position</doc>
      </member>
      <member name="mono"
              value="-2"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_MONO"
              glib:nick="mono">
        <doc xml:space="preserve">Mono without direction;
    can only be used with 1 channel</doc>
      </member>
      <member name="invalid"
              value="-1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_INVALID"
              glib:nick="invalid">
        <doc xml:space="preserve">invalid position</doc>
      </member>
      <member name="front_left"
              value="0"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT"
              glib:nick="front-left">
        <doc xml:space="preserve">Front left</doc>
      </member>
      <member name="front_right"
              value="1"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT"
              glib:nick="front-right">
        <doc xml:space="preserve">Front right</doc>
      </member>
      <member name="front_center"
              value="2"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER"
              glib:nick="front-center">
        <doc xml:space="preserve">Front center</doc>
      </member>
      <member name="lfe1"
              value="3"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_LFE1"
              glib:nick="lfe1">
        <doc xml:space="preserve">Low-frequency effects 1 (subwoofer)</doc>
      </member>
      <member name="rear_left"
              value="4"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_LEFT"
              glib:nick="rear-left">
        <doc xml:space="preserve">Rear left</doc>
      </member>
      <member name="rear_right"
              value="5"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT"
              glib:nick="rear-right">
        <doc xml:space="preserve">Rear right</doc>
      </member>
      <member name="front_left_of_center"
              value="6"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER"
              glib:nick="front-left-of-center">
        <doc xml:space="preserve">Front left of center</doc>
      </member>
      <member name="front_right_of_center"
              value="7"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER"
              glib:nick="front-right-of-center">
        <doc xml:space="preserve">Front right of center</doc>
      </member>
      <member name="rear_center"
              value="8"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_REAR_CENTER"
              glib:nick="rear-center">
        <doc xml:space="preserve">Rear center</doc>
      </member>
      <member name="lfe2"
              value="9"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_LFE2"
              glib:nick="lfe2">
        <doc xml:space="preserve">Low-frequency effects 2 (subwoofer)</doc>
      </member>
      <member name="side_left"
              value="10"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT"
              glib:nick="side-left">
        <doc xml:space="preserve">Side left</doc>
      </member>
      <member name="side_right"
              value="11"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT"
              glib:nick="side-right">
        <doc xml:space="preserve">Side right</doc>
      </member>
      <member name="top_front_left"
              value="12"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_LEFT"
              glib:nick="top-front-left">
        <doc xml:space="preserve">Top front left</doc>
      </member>
      <member name="top_front_right"
              value="13"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_RIGHT"
              glib:nick="top-front-right">
        <doc xml:space="preserve">Top front right</doc>
      </member>
      <member name="top_front_center"
              value="14"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_FRONT_CENTER"
              glib:nick="top-front-center">
        <doc xml:space="preserve">Top front center</doc>
      </member>
      <member name="top_center"
              value="15"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_CENTER"
              glib:nick="top-center">
        <doc xml:space="preserve">Top center</doc>
      </member>
      <member name="top_rear_left"
              value="16"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_REAR_LEFT"
              glib:nick="top-rear-left">
        <doc xml:space="preserve">Top rear left</doc>
      </member>
      <member name="top_rear_right"
              value="17"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_REAR_RIGHT"
              glib:nick="top-rear-right">
        <doc xml:space="preserve">Top rear right</doc>
      </member>
      <member name="top_side_left"
              value="18"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_LEFT"
              glib:nick="top-side-left">
        <doc xml:space="preserve">Top side right</doc>
      </member>
      <member name="top_side_right"
              value="19"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_SIDE_RIGHT"
              glib:nick="top-side-right">
        <doc xml:space="preserve">Top rear right</doc>
      </member>
      <member name="top_rear_center"
              value="20"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_TOP_REAR_CENTER"
              glib:nick="top-rear-center">
        <doc xml:space="preserve">Top rear center</doc>
      </member>
      <member name="bottom_front_center"
              value="21"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_CENTER"
              glib:nick="bottom-front-center">
        <doc xml:space="preserve">Bottom front center</doc>
      </member>
      <member name="bottom_front_left"
              value="22"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_LEFT"
              glib:nick="bottom-front-left">
        <doc xml:space="preserve">Bottom front left</doc>
      </member>
      <member name="bottom_front_right"
              value="23"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_BOTTOM_FRONT_RIGHT"
              glib:nick="bottom-front-right">
        <doc xml:space="preserve">Bottom front right</doc>
      </member>
      <member name="wide_left"
              value="24"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_WIDE_LEFT"
              glib:nick="wide-left">
        <doc xml:space="preserve">Wide left (between front left and side left)</doc>
      </member>
      <member name="wide_right"
              value="25"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_WIDE_RIGHT"
              glib:nick="wide-right">
        <doc xml:space="preserve">Wide right (between front right and side right)</doc>
      </member>
      <member name="surround_left"
              value="26"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SURROUND_LEFT"
              glib:nick="surround-left">
        <doc xml:space="preserve">Surround left (between rear left and side left)</doc>
      </member>
      <member name="surround_right"
              value="27"
              c:identifier="GST_AUDIO_CHANNEL_POSITION_SURROUND_RIGHT"
              glib:nick="surround-right">
        <doc xml:space="preserve">Surround right (between rear right and side right)</doc>
      </member>
    </enumeration>
    <record name="AudioClippingMeta"
            c:type="GstAudioClippingMeta"
            version="1.8">
      <doc xml:space="preserve">Extra buffer metadata describing how much audio has to be clipped from
the start or end of a buffer. This is used for compressed formats, where
the first frame usually has some additional samples due to encoder and
decoder delays, and the last frame usually has some additional samples to
be able to fill the complete last frame.

This is used to ensure that decoded data in the end has the same amount of
samples, and multiply decoded streams can be gaplessly concatenated.

Note: If clipping of the start is done by adjusting the segment, this meta
has to be dropped from buffers as otherwise clipping could happen twice.</doc>
      <field name="meta" writable="1">
        <doc xml:space="preserve">parent #GstMeta</doc>
        <type name="Gst.Meta" c:type="GstMeta"/>
      </field>
      <field name="format" writable="1">
        <doc xml:space="preserve">GstFormat of @start and @stop, GST_FORMAT_DEFAULT is samples</doc>
        <type name="Gst.Format" c:type="GstFormat"/>
      </field>
      <field name="start" writable="1">
        <doc xml:space="preserve">Amount of audio to clip from start of buffer</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="end" writable="1">
        <doc xml:space="preserve">Amount of  to clip from end of buffer</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <function name="get_info"
                c:identifier="gst_audio_clipping_meta_get_info">
        <return-value transfer-ownership="none">
          <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
        </return-value>
      </function>
    </record>
    <class name="AudioClock"
           c:symbol-prefix="audio_clock"
           c:type="GstAudioClock"
           parent="Gst.SystemClock"
           glib:type-name="GstAudioClock"
           glib:get-type="gst_audio_clock_get_type"
           glib:type-struct="AudioClockClass">
      <doc xml:space="preserve">#GstAudioClock makes it easy for elements to implement a #GstClock, they
simply need to provide a function that returns the current clock time.

This object is internally used to implement the clock in #GstAudioBaseSink.</doc>
      <constructor name="new" c:identifier="gst_audio_clock_new">
        <doc xml:space="preserve">Create a new #GstAudioClock instance. Whenever the clock time should be
calculated it will call @func with @user_data. When @func returns
#GST_CLOCK_TIME_NONE, the clock will return the last reported time.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstAudioClock casted to a #GstClock.</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the clock</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">a function</doc>
            <type name="AudioClockGetTimeFunc"
                  c:type="GstAudioClockGetTimeFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_notify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve">#GDestroyNotify for @user_data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="adjust" c:identifier="gst_audio_clock_adjust">
        <doc xml:space="preserve">Adjust @time with the internal offset of the audio clock.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">@time adjusted with the internal offset.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="AudioClock" c:type="GstAudioClock*"/>
          </instance-parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_time" c:identifier="gst_audio_clock_get_time">
        <doc xml:space="preserve">Report the time as returned by the #GstAudioClockGetTimeFunc without applying
any offsets.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the time as reported by the time function of the audio clock</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="AudioClock" c:type="GstAudioClock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invalidate" c:identifier="gst_audio_clock_invalidate">
        <doc xml:space="preserve">Invalidate the clock function. Call this function when the provided
#GstAudioClockGetTimeFunc cannot be called anymore, for example, when the
user_data becomes invalid.

After calling this function, @clock will return the last returned time for
the rest of its lifetime.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="AudioClock" c:type="GstAudioClock*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gst_audio_clock_reset">
        <doc xml:space="preserve">Inform @clock that future calls to #GstAudioClockGetTimeFunc will return values
starting from @time. The clock will update an internal offset to make sure that
future calls to internal_time will return an increasing result as required by
the #GstClock object.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="clock" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioClock</doc>
            <type name="AudioClock" c:type="GstAudioClock*"/>
          </instance-parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve">a #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <field name="clock">
        <type name="Gst.SystemClock" c:type="GstSystemClock"/>
      </field>
      <field name="func">
        <type name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc"/>
      </field>
      <field name="user_data">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="destroy_notify">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="last_time" readable="0" private="1">
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </field>
      <field name="time_offset" readable="0" private="1">
        <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioClockClass"
            c:type="GstAudioClockClass"
            glib:is-gtype-struct-for="AudioClock">
      <field name="parent_class">
        <type name="Gst.SystemClockClass" c:type="GstSystemClockClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioClockGetTimeFunc" c:type="GstAudioClockGetTimeFunc">
      <doc xml:space="preserve">This function will be called whenever the current clock time needs to be
calculated. If this function returns #GST_CLOCK_TIME_NONE, the last reported
time will be returned by the clock.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the current time or #GST_CLOCK_TIME_NONE if the previous time should
be used.</doc>
        <type name="Gst.ClockTime" c:type="GstClockTime"/>
      </return-value>
      <parameters>
        <parameter name="clock" transfer-ownership="none">
          <doc xml:space="preserve">the #GstAudioClock</doc>
          <type name="Gst.Clock" c:type="GstClock*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AudioConverter"
            c:type="GstAudioConverter"
            glib:type-name="GstAudioConverter"
            glib:get-type="gst_audio_converter_get_type"
            c:symbol-prefix="audio_converter">
      <constructor name="new" c:identifier="gst_audio_converter_new">
        <doc xml:space="preserve">Create a new #GstAudioConverter that is able to convert between @in and @out
audio formats.

@config contains extra configuration options, see #GST_VIDEO_CONVERTER_OPT_*
parameters for details about the options and values.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstAudioConverter or %NULL if conversion is not possible.</doc>
          <type name="AudioConverter" c:type="GstAudioConverter*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">extra #GstAudioConverterFlags</doc>
            <type name="AudioConverterFlags" c:type="GstAudioConverterFlags"/>
          </parameter>
          <parameter name="in_info" transfer-ownership="none">
            <doc xml:space="preserve">a source #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </parameter>
          <parameter name="out_info" transfer-ownership="none">
            <doc xml:space="preserve">a destination #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </parameter>
          <parameter name="config"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstStructure with configuration options</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="convert"
              c:identifier="gst_audio_converter_convert"
              version="1.14">
        <doc xml:space="preserve">Convenience wrapper around gst_audio_converter_samples(), which will
perform allocation of the output buffer based on the result from
gst_audio_converter_get_out_frames().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is the conversion could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">extra #GstAudioConverterFlags</doc>
            <type name="AudioConverterFlags" c:type="GstAudioConverterFlags"/>
          </parameter>
          <parameter name="in" transfer-ownership="none">
            <doc xml:space="preserve">input data</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="in_size" transfer-ownership="none">
            <doc xml:space="preserve">size of @in</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a pointer where
 the output data will be written</doc>
            <array length="4" zero-terminated="0" c:type="gpointer*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="out_size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a pointer where the size of @out will be written</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_audio_converter_free">
        <doc xml:space="preserve">Free a previously allocated @convert instance.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_config" c:identifier="gst_audio_converter_get_config">
        <doc xml:space="preserve">Get the current configuration of @convert.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">
  a #GstStructure that remains valid for as long as @convert is valid
  or until gst_audio_converter_update_config() is called.</doc>
          <type name="Gst.Structure" c:type="const GstStructure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
          <parameter name="in_rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">result input rate</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="out_rate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">result output rate</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_in_frames"
              c:identifier="gst_audio_converter_get_in_frames">
        <doc xml:space="preserve">Calculate how many input frames are currently needed by @convert to produce
@out_frames of output frames.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of input frames</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
          <parameter name="out_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of output frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_latency"
              c:identifier="gst_audio_converter_get_max_latency">
        <doc xml:space="preserve">Get the maximum number of input frames that the converter would
need before producing output.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the latency of @convert as expressed in the number of
frames.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_out_frames"
              c:identifier="gst_audio_converter_get_out_frames">
        <doc xml:space="preserve">Calculate how many output frames can be produced when @in_frames input
frames are given to @convert.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of output frames</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
          <parameter name="in_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of input frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gst_audio_converter_reset">
        <doc xml:space="preserve">Reset @convert to the state it was when it was first created, clearing
any history it might currently have.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="samples" c:identifier="gst_audio_converter_samples">
        <doc xml:space="preserve">Perform the conversion with @in_frames in @in to @out_frames in @out
using @convert.

In case the samples are interleaved, @in and @out must point to an
array with a single element pointing to a block of interleaved samples.

If non-interleaved samples are used, @in and @out must point to an
array with pointers to memory blocks, one for each channel.

@in may be %NULL, in which case @in_frames of silence samples are processed
by the converter.

This function always produces @out_frames of output and consumes @in_frames of
input. Use gst_audio_converter_get_out_frames() and
gst_audio_converter_get_in_frames() to make sure @in_frames and @out_frames
are matching and @in and @out point to enough memory.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE is the conversion could be performed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">extra #GstAudioConverterFlags</doc>
            <type name="AudioConverterFlags" c:type="GstAudioConverterFlags"/>
          </parameter>
          <parameter name="in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">input frames</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="in_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of input frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">output frames</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="out_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of output frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="supports_inplace"
              c:identifier="gst_audio_converter_supports_inplace">
        <doc xml:space="preserve">Returns whether the audio converter can perform the conversion in-place.
The return value would be typically input to gst_base_transform_set_in_place()</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE when the conversion can be done in place.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update_config"
              c:identifier="gst_audio_converter_update_config">
        <doc xml:space="preserve">Set @in_rate, @out_rate and @config as extra configuration for @convert.

@in_rate and @out_rate specify the new sample rates of input and output
formats. A value of 0 leaves the sample rate unchanged.

@config can be %NULL, in which case, the current configuration is not
changed.

If the parameters in @config can not be set exactly, this function returns
%FALSE and will try to update as much state as possible. The new state can
then be retrieved and refined with gst_audio_converter_get_config().

Look at the #GST_AUDIO_CONVERTER_OPT_* fields to check valid configuration
option and values.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE when the new parameters could be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="convert" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioConverter</doc>
            <type name="AudioConverter" c:type="GstAudioConverter*"/>
          </instance-parameter>
          <parameter name="in_rate" transfer-ownership="none">
            <doc xml:space="preserve">input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_rate" transfer-ownership="none">
            <doc xml:space="preserve">output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="config"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstStructure or %NULL</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="AudioConverterFlags"
              glib:type-name="GstAudioConverterFlags"
              glib:get-type="gst_audio_converter_flags_get_type"
              c:type="GstAudioConverterFlags">
      <doc xml:space="preserve">Extra flags passed to gst_audio_converter_new() and gst_audio_converter_samples().</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_CONVERTER_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flag</doc>
      </member>
      <member name="in_writable"
              value="1"
              c:identifier="GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE"
              glib:nick="in-writable">
        <doc xml:space="preserve">the input sample arrays are writable and can be
   used as temporary storage during conversion.</doc>
      </member>
      <member name="variable_rate"
              value="2"
              c:identifier="GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE"
              glib:nick="variable-rate">
        <doc xml:space="preserve">allow arbitrary rate updates with
   gst_audio_converter_update_config().</doc>
      </member>
    </bitfield>
    <class name="AudioDecoder"
           c:symbol-prefix="audio_decoder"
           c:type="GstAudioDecoder"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstAudioDecoder"
           glib:get-type="gst_audio_decoder_get_type"
           glib:type-struct="AudioDecoderClass">
      <doc xml:space="preserve">This base class is for audio decoders turning encoded data into
raw audio samples.

GstAudioDecoder and subclass should cooperate as follows.

## Configuration

  * Initially, GstAudioDecoder calls @start when the decoder element
    is activated, which allows subclass to perform any global setup.
    Base class (context) parameters can already be set according to subclass
    capabilities (or possibly upon receive more information in subsequent
    @set_format).
  * GstAudioDecoder calls @set_format to inform subclass of the format
    of input audio data that it is about to receive.
    While unlikely, it might be called more than once, if changing input
    parameters require reconfiguration.
  * GstAudioDecoder calls @stop at end of all processing.

As of configuration stage, and throughout processing, GstAudioDecoder
provides various (context) parameters, e.g. describing the format of
output audio data (valid when output caps have been set) or current parsing state.
Conversely, subclass can and should configure context to inform
base class of its expectation w.r.t. buffer handling.

## Data processing
    * Base class gathers input data, and optionally allows subclass
      to parse this into subsequently manageable (as defined by subclass)
      chunks.  Such chunks are subsequently referred to as 'frames',
      though they may or may not correspond to 1 (or more) audio format frame.
    * Input frame is provided to subclass' @handle_frame.
    * If codec processing results in decoded data, subclass should call
      @gst_audio_decoder_finish_frame to have decoded data pushed
      downstream.
    * Just prior to actually pushing a buffer downstream,
      it is passed to @pre_push.  Subclass should either use this callback
      to arrange for additional downstream pushing or otherwise ensure such
      custom pushing occurs after at least a method call has finished since
      setting src pad caps.
    * During the parsing process GstAudioDecoderClass will handle both
      srcpad and sinkpad events. Sink events will be passed to subclass
      if @event callback has been provided.

## Shutdown phase

  * GstAudioDecoder class calls @stop to inform the subclass that data
    parsing will be stopped.

Subclass is responsible for providing pad template caps for
source and sink pads. The pads need to be named "sink" and "src". It also
needs to set the fixed caps on srcpad, when the format is ensured.  This
is typically when base class calls subclass' @set_format function, though
it might be delayed until calling @gst_audio_decoder_finish_frame.

In summary, above process should have subclass concentrating on
codec data processing while leaving other matters to base class,
such as most notably timestamp handling.  While it may exert more control
in this area (see e.g. @pre_push), it is very much not recommended.

In particular, base class will try to arrange for perfect output timestamps
as much as possible while tracking upstream timestamps.
To this end, if deviation between the next ideal expected perfect timestamp
and upstream exceeds #GstAudioDecoder:tolerance, then resync to upstream
occurs (which would happen always if the tolerance mechanism is disabled).

In non-live pipelines, baseclass can also (configurably) arrange for
output buffer aggregation which may help to redue large(r) numbers of
small(er) buffers being pushed and processed downstream.

On the other hand, it should be noted that baseclass only provides limited
seeking support (upon explicit subclass request), as full-fledged support
should rather be left to upstream demuxer, parser or alike.  This simple
approach caters for seeking and duration reporting using estimated input
bitrates.

Things that subclass need to take care of:

  * Provide pad templates
  * Set source pad caps when appropriate
  * Set user-configurable properties to sane defaults for format and
     implementing codec at hand, and convey some subclass capabilities and
     expectations in context.

  * Accept data in @handle_frame and provide encoded results to
     @gst_audio_decoder_finish_frame.  If it is prepared to perform
     PLC, it should also accept NULL data in @handle_frame and provide for
     data for indicated duration.</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decide_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="hard" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="getcaps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="negotiate" invoker="negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstAudioInfo.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="adapter" transfer-ownership="none">
            <type name="GstBase.Adapter" c:type="GstAdapter*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_push">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="propose_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_format">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_meta">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="meta" transfer-ownership="none">
            <type name="Gst.Meta" c:type="GstMeta*"/>
          </parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="allocate_output_buffer"
              c:identifier="gst_audio_decoder_allocate_output_buffer">
        <doc xml:space="preserve">Helper function that allocates a buffer to hold an audio frame
for @dec's current output format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">allocated buffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_frame"
              c:identifier="gst_audio_decoder_finish_frame">
        <doc xml:space="preserve">Collects decoded data and pushes it downstream.

@buf may be NULL in which case the indicated number of frames
are discarded and considered to have produced no output
(e.g. lead-in or setup frames).
Otherwise, source pad caps must be set when it is called with valid
data in @buf.

Note that a frame received in gst_audio_decoder_handle_frame() may be
invalidated by a call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstFlowReturn that should be escalated to caller (of caller)</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">decoded data</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="frames" transfer-ownership="none">
            <doc xml:space="preserve">number of decoded frames represented by decoded data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allocator"
              c:identifier="gst_audio_decoder_get_allocator">
        <doc xml:space="preserve">Lets #GstAudioDecoder sub-classes to know the memory @allocator
used by the base class and its @params.

Unref the @allocator after use it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GstAllocator
used</doc>
            <type name="Gst.Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the
#GstAllocatorParams of @allocator</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_audio_info"
              c:identifier="gst_audio_decoder_get_audio_info">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstAudioInfo describing the input audio format</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_delay" c:identifier="gst_audio_decoder_get_delay">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured decoder delay</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drainable"
              c:identifier="gst_audio_decoder_get_drainable">
        <doc xml:space="preserve">Queries decoder drain handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if drainable handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_estimate_rate"
              c:identifier="gst_audio_decoder_get_estimate_rate">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured byte to time conversion setting</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_latency" c:identifier="gst_audio_decoder_get_latency">
        <doc xml:space="preserve">Sets the variables pointed to by @min and @max to the currently configured
latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="min"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_errors"
              c:identifier="gst_audio_decoder_get_max_errors">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured decoder tolerated error count.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_min_latency"
              c:identifier="gst_audio_decoder_get_min_latency">
        <doc xml:space="preserve">Queries decoder's latency aggregation.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">aggregation latency.

MT safe.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_needs_format"
              c:identifier="gst_audio_decoder_get_needs_format">
        <doc xml:space="preserve">Queries decoder required format handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if required format handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parse_state"
              c:identifier="gst_audio_decoder_get_parse_state">
        <doc xml:space="preserve">Return current parsing (sync and eos) state.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="sync"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to a variable to hold the current sync state</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="eos"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to a variable to hold the current eos state</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_plc" c:identifier="gst_audio_decoder_get_plc">
        <doc xml:space="preserve">Queries decoder packet loss concealment handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if packet loss concealment is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_plc_aware"
              c:identifier="gst_audio_decoder_get_plc_aware">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured plc handling</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tolerance"
              c:identifier="gst_audio_decoder_get_tolerance">
        <doc xml:space="preserve">Queries current audio jitter tolerance threshold.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">decoder audio jitter tolerance threshold.

MT safe.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="merge_tags" c:identifier="gst_audio_decoder_merge_tags">
        <doc xml:space="preserve">Sets the audio decoder tags and how they should be merged with any
upstream stream tags. This will override any tags previously-set
with gst_audio_decoder_merge_tags().

Note that this is provided for convenience, and the subclass is
not required to use this and can still do tag handling on its own.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="tags"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstTagList to merge, or NULL</doc>
            <type name="Gst.TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE</doc>
            <type name="Gst.TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="negotiate" c:identifier="gst_audio_decoder_negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstAudioInfo.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="proxy_getcaps"
              c:identifier="gst_audio_decoder_proxy_getcaps"
              version="1.6">
        <doc xml:space="preserve">Returns caps that express @caps (or sink template caps if @caps == NULL)
restricted to rate/channels/... combinations supported by downstream
elements.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstCaps owned by caller</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="decoder" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">initial caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">filter caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_allocation_caps"
              c:identifier="gst_audio_decoder_set_allocation_caps"
              version="1.10">
        <doc xml:space="preserve">Sets a caps in allocation query which are different from the set
pad's caps. Use this function before calling
gst_audio_decoder_negotiate(). Setting to %NULL the allocation
query will use the caps from the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="allocation_caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstCaps or %NULL</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drainable"
              c:identifier="gst_audio_decoder_set_drainable">
        <doc xml:space="preserve">Configures decoder drain handling.  If drainable, subclass might
be handed a NULL buffer to have it return any leftover decoded data.
Otherwise, it is not considered so capable and will only ever be passed
real data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_estimate_rate"
              c:identifier="gst_audio_decoder_set_estimate_rate">
        <doc xml:space="preserve">Allows baseclass to perform byte to time estimated conversion.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">whether to enable byte to time conversion</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency" c:identifier="gst_audio_decoder_set_latency">
        <doc xml:space="preserve">Sets decoder latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve">minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve">maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_errors"
              c:identifier="gst_audio_decoder_set_max_errors">
        <doc xml:space="preserve">Sets numbers of tolerated decoder errors, where a tolerated one is then only
warned about, but more than tolerated will lead to fatal error. You can set
-1 for never returning fatal errors. Default is set to
GST_AUDIO_DECODER_MAX_ERRORS.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">max tolerated errors</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_min_latency"
              c:identifier="gst_audio_decoder_set_min_latency">
        <doc xml:space="preserve">Sets decoder minimum aggregation latency.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">new minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_needs_format"
              c:identifier="gst_audio_decoder_set_needs_format">
        <doc xml:space="preserve">Configures decoder format needs.  If enabled, subclass needs to be
negotiated with format caps before it can process any data.  It will then
never be handed any data before it has been configured.
Otherwise, it might be handed data without having been configured and
is then expected being able to do so either by default
or based on the input data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_output_format"
              c:identifier="gst_audio_decoder_set_output_format">
        <doc xml:space="preserve">Configure output info on the srcpad of @dec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">#GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_plc" c:identifier="gst_audio_decoder_set_plc">
        <doc xml:space="preserve">Enable or disable decoder packet loss concealment, provided subclass
and codec are capable and allow handling plc.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_plc_aware"
              c:identifier="gst_audio_decoder_set_plc_aware">
        <doc xml:space="preserve">Indicates whether or not subclass handles packet loss concealment (plc).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="plc" transfer-ownership="none">
            <doc xml:space="preserve">new plc state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tolerance"
              c:identifier="gst_audio_decoder_set_tolerance">
        <doc xml:space="preserve">Configures decoder audio jitter tolerance threshold.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dec" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:space="preserve">new tolerance</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_use_default_pad_acceptcaps"
              c:identifier="gst_audio_decoder_set_use_default_pad_acceptcaps"
              version="1.6">
        <doc xml:space="preserve">Lets #GstAudioDecoder sub-classes decide if they want the sink pad
to use the default pad query handler to reply to accept-caps queries.

By setting this to true it is possible to further customize the default
handler with %GST_PAD_SET_ACCEPT_INTERSECT and
%GST_PAD_SET_ACCEPT_TEMPLATE</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="decoder" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDecoder</doc>
            <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
          </instance-parameter>
          <parameter name="use" transfer-ownership="none">
            <doc xml:space="preserve">if the default pad accept-caps query handling should be used</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="min-latency" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="plc" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="tolerance" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="stream_lock">
        <type name="GLib.RecMutex" c:type="GRecMutex"/>
      </field>
      <field name="input_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="output_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioDecoderPrivate" c:type="GstAudioDecoderPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioDecoderClass"
            c:type="GstAudioDecoderClass"
            glib:is-gtype-struct-for="AudioDecoder">
      <doc xml:space="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @handle_frame (and likely @set_format) needs to be
overridden.</doc>
      <field name="element_class">
        <doc xml:space="preserve">The parent class structure</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_format">
        <callback name="set_format">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse">
        <callback name="parse">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="adapter" transfer-ownership="none">
              <type name="GstBase.Adapter" c:type="GstAdapter*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_frame">
        <callback name="handle_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="hard" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push">
        <callback name="pre_push">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event">
        <callback name="sink_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the negotiation succeeded, else %FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioDecoder</doc>
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decide_allocation">
        <callback name="decide_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="propose_allocation">
        <callback name="propose_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_query">
        <callback name="sink_query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_query">
        <callback name="src_query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="getcaps">
        <callback name="getcaps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="dec" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="filter" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_meta">
        <callback name="transform_meta">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioDecoder" c:type="GstAudioDecoder*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="meta" transfer-ownership="none">
              <type name="Gst.Meta" c:type="GstMeta*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="16">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioDecoderPrivate"
            c:type="GstAudioDecoderPrivate"
            disguised="1">
    </record>
    <enumeration name="AudioDitherMethod"
                 glib:type-name="GstAudioDitherMethod"
                 glib:get-type="gst_audio_dither_method_get_type"
                 c:type="GstAudioDitherMethod">
      <doc xml:space="preserve">Set of available dithering methods.</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_DITHER_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No dithering</doc>
      </member>
      <member name="rpdf"
              value="1"
              c:identifier="GST_AUDIO_DITHER_RPDF"
              glib:nick="rpdf">
        <doc xml:space="preserve">Rectangular dithering</doc>
      </member>
      <member name="tpdf"
              value="2"
              c:identifier="GST_AUDIO_DITHER_TPDF"
              glib:nick="tpdf">
        <doc xml:space="preserve">Triangular dithering (default)</doc>
      </member>
      <member name="tpdf_hf"
              value="3"
              c:identifier="GST_AUDIO_DITHER_TPDF_HF"
              glib:nick="tpdf-hf">
        <doc xml:space="preserve">High frequency triangular dithering</doc>
      </member>
    </enumeration>
    <record name="AudioDownmixMeta" c:type="GstAudioDownmixMeta">
      <doc xml:space="preserve">Extra buffer metadata describing audio downmixing matrix. This metadata is
attached to audio buffers and contains a matrix to downmix the buffer number
of channels to @channels.

@matrix is an two-dimensional array of @to_channels times @from_channels
coefficients, i.e. the i-th output channels is constructed by multiplicating
the input channels with the coefficients in @matrix[i] and taking the sum
of the results.</doc>
      <field name="meta" writable="1">
        <doc xml:space="preserve">parent #GstMeta</doc>
        <type name="Gst.Meta" c:type="GstMeta"/>
      </field>
      <field name="from_position" writable="1">
        <doc xml:space="preserve">the channel positions of the source</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </field>
      <field name="to_position" writable="1">
        <doc xml:space="preserve">the channel positions of the destination</doc>
        <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
      </field>
      <field name="from_channels" writable="1">
        <doc xml:space="preserve">the number of channels of the source</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="to_channels" writable="1">
        <doc xml:space="preserve">the number of channels of the destination</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="matrix" writable="1">
        <doc xml:space="preserve">the matrix coefficients.</doc>
        <type name="gfloat" c:type="gfloat**"/>
      </field>
      <function name="get_info" c:identifier="gst_audio_downmix_meta_get_info">
        <return-value transfer-ownership="none">
          <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
        </return-value>
      </function>
    </record>
    <class name="AudioEncoder"
           c:symbol-prefix="audio_encoder"
           c:type="GstAudioEncoder"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstAudioEncoder"
           glib:get-type="gst_audio_encoder_get_type"
           glib:type-struct="AudioEncoderClass">
      <doc xml:space="preserve">This base class is for audio encoders turning raw audio samples into
encoded audio data.

GstAudioEncoder and subclass should cooperate as follows.

## Configuration

  * Initially, GstAudioEncoder calls @start when the encoder element
    is activated, which allows subclass to perform any global setup.

  * GstAudioEncoder calls @set_format to inform subclass of the format
    of input audio data that it is about to receive.  Subclass should
    setup for encoding and configure various base class parameters
    appropriately, notably those directing desired input data handling.
    While unlikely, it might be called more than once, if changing input
    parameters require reconfiguration.

  * GstAudioEncoder calls @stop at end of all processing.

As of configuration stage, and throughout processing, GstAudioEncoder
maintains various parameters that provide required context,
e.g. describing the format of input audio data.
Conversely, subclass can and should configure these context parameters
to inform base class of its expectation w.r.t. buffer handling.

## Data processing

    * Base class gathers input sample data (as directed by the context's
      frame_samples and frame_max) and provides this to subclass' @handle_frame.
    * If codec processing results in encoded data, subclass should call
      gst_audio_encoder_finish_frame() to have encoded data pushed
      downstream. Alternatively, it might also call
      gst_audio_encoder_finish_frame() (with a NULL buffer and some number of
      dropped samples) to indicate dropped (non-encoded) samples.
    * Just prior to actually pushing a buffer downstream,
      it is passed to @pre_push.
    * During the parsing process GstAudioEncoderClass will handle both
      srcpad and sinkpad events. Sink events will be passed to subclass
      if @event callback has been provided.

## Shutdown phase

  * GstAudioEncoder class calls @stop to inform the subclass that data
    parsing will be stopped.

Subclass is responsible for providing pad template caps for
source and sink pads. The pads need to be named "sink" and "src". It also
needs to set the fixed caps on srcpad, when the format is ensured.  This
is typically when base class calls subclass' @set_format function, though
it might be delayed until calling @gst_audio_encoder_finish_frame.

In summary, above process should have subclass concentrating on
codec data processing while leaving other matters to base class,
such as most notably timestamp handling.  While it may exert more control
in this area (see e.g. @pre_push), it is very much not recommended.

In particular, base class will either favor tracking upstream timestamps
(at the possible expense of jitter) or aim to arrange for a perfect stream of
output timestamps, depending on #GstAudioEncoder:perfect-timestamp.
However, in the latter case, the input may not be so perfect or ideal, which
is handled as follows.  An input timestamp is compared with the expected
timestamp as dictated by input sample stream and if the deviation is less
than #GstAudioEncoder:tolerance, the deviation is discarded.
Otherwise, it is considered a discontuinity and subsequent output timestamp
is resynced to the new position after performing configured discontinuity
processing.  In the non-perfect-timestamp case, an upstream variation
exceeding tolerance only leads to marking DISCONT on subsequent outgoing
(while timestamps are adjusted to upstream regardless of variation).
While DISCONT is also marked in the perfect-timestamp case, this one
optionally (see #GstAudioEncoder:hard-resync)
performs some additional steps, such as clipping of (early) input samples
or draining all currently remaining input data, depending on the direction
of the discontuinity.

If perfect timestamps are arranged, it is also possible to request baseclass
(usually set by subclass) to provide additional buffer metadata (in OFFSET
and OFFSET_END) fields according to granule defined semantics currently
needed by oggmux.  Specifically, OFFSET is set to granulepos (= sample count
including buffer) and OFFSET_END to corresponding timestamp (as determined
by same sample count and sample rate).

Things that subclass need to take care of:

  * Provide pad templates
  * Set source pad caps when appropriate
  * Inform base class of buffer processing needs using context's
     frame_samples and frame_bytes.
  * Set user-configurable properties to sane defaults for format and
     implementing codec at hand, e.g. those controlling timestamp behaviour
     and discontinuity processing.
  * Accept data in @handle_frame and provide encoded results to
     gst_audio_encoder_finish_frame().</doc>
      <implements name="Gst.Preset"/>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decide_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="getcaps">
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_frame">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="negotiate" invoker="negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstCaps.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_push">
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="propose_allocation">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_format">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="encoder" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_query">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="encoder" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_meta">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="meta" transfer-ownership="none">
            <type name="Gst.Meta" c:type="GstMeta*"/>
          </parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="allocate_output_buffer"
              c:identifier="gst_audio_encoder_allocate_output_buffer">
        <doc xml:space="preserve">Helper function that allocates a buffer to hold an encoded audio frame
for @enc's current output format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">allocated buffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve">size of the buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_frame"
              c:identifier="gst_audio_encoder_finish_frame">
        <doc xml:space="preserve">Collects encoded data and pushes encoded data downstream.
Source pad caps must be set when this is called.

If @samples &lt; 0, then best estimate is all samples provided to encoder
(subclass) so far.  @buf may be NULL, in which case next number of @samples
are considered discarded, e.g. as a result of discontinuous transmission,
and a discontinuity is marked.

Note that samples received in gst_audio_encoder_handle_frame()
may be invalidated by a call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstFlowReturn that should be escalated to caller (of caller)</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">encoded data</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="samples" transfer-ownership="none">
            <doc xml:space="preserve">number of samples (per channel) represented by encoded data</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allocator"
              c:identifier="gst_audio_encoder_get_allocator">
        <doc xml:space="preserve">Lets #GstAudioEncoder sub-classes to know the memory @allocator
used by the base class and its @params.

Unref the @allocator after use it.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GstAllocator
used</doc>
            <type name="Gst.Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">the
#GstAllocatorParams of @allocator</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_audio_info"
              c:identifier="gst_audio_encoder_get_audio_info">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstAudioInfo describing the input audio format</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drainable"
              c:identifier="gst_audio_encoder_get_drainable">
        <doc xml:space="preserve">Queries encoder drain handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if drainable handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_max"
              c:identifier="gst_audio_encoder_get_frame_max">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured maximum handled frames</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_samples_max"
              c:identifier="gst_audio_encoder_get_frame_samples_max">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently maximum requested samples per frame</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_samples_min"
              c:identifier="gst_audio_encoder_get_frame_samples_min">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently minimum requested samples per frame</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hard_min"
              c:identifier="gst_audio_encoder_get_hard_min">
        <doc xml:space="preserve">Queries encoder hard minimum handling.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if hard minimum handling is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hard_resync"
              c:identifier="gst_audio_encoder_get_hard_resync">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_latency" c:identifier="gst_audio_encoder_get_latency">
        <doc xml:space="preserve">Sets the variables pointed to by @min and @max to the currently configured
latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="min"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to storage to hold maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_lookahead"
              c:identifier="gst_audio_encoder_get_lookahead">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">currently configured encoder lookahead</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mark_granule"
              c:identifier="gst_audio_encoder_get_mark_granule">
        <doc xml:space="preserve">Queries if the encoder will handle granule marking.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if granule marking is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_perfect_timestamp"
              c:identifier="gst_audio_encoder_get_perfect_timestamp">
        <doc xml:space="preserve">Queries encoder perfect timestamp behaviour.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if perfect timestamp setting enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tolerance"
              c:identifier="gst_audio_encoder_get_tolerance">
        <doc xml:space="preserve">Queries current audio jitter tolerance threshold.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">encoder audio jitter tolerance threshold.

MT safe.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="merge_tags" c:identifier="gst_audio_encoder_merge_tags">
        <doc xml:space="preserve">Sets the audio encoder tags and how they should be merged with any
upstream stream tags. This will override any tags previously-set
with gst_audio_encoder_merge_tags().

Note that this is provided for convenience, and the subclass is
not required to use this and can still do tag handling on its own.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="tags"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstTagList to merge, or NULL to unset
    previously-set tags</doc>
            <type name="Gst.TagList" c:type="const GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve">the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE</doc>
            <type name="Gst.TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="negotiate" c:identifier="gst_audio_encoder_negotiate">
        <doc xml:space="preserve">Negotiate with downstream elements to currently configured #GstCaps.
Unmark GST_PAD_FLAG_NEED_RECONFIGURE in any case. But mark it again if
negotiate fails.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="proxy_getcaps"
              c:identifier="gst_audio_encoder_proxy_getcaps">
        <doc xml:space="preserve">Returns caps that express @caps (or sink template caps if @caps == NULL)
restricted to channel/rate combinations supported by downstream elements
(e.g. muxers).</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GstCaps owned by caller</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">initial caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">filter caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_allocation_caps"
              c:identifier="gst_audio_encoder_set_allocation_caps"
              version="1.10">
        <doc xml:space="preserve">Sets a caps in allocation query which are different from the set
pad's caps. Use this function before calling
gst_audio_encoder_negotiate(). Setting to %NULL the allocation
query will use the caps from the pad.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="allocation_caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstCaps or %NULL</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drainable"
              c:identifier="gst_audio_encoder_set_drainable">
        <doc xml:space="preserve">Configures encoder drain handling.  If drainable, subclass might
be handed a NULL buffer to have it return any leftover encoded data.
Otherwise, it is not considered so capable and will only ever be passed
real data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_max"
              c:identifier="gst_audio_encoder_set_frame_max">
        <doc xml:space="preserve">Sets max number of frames accepted at once (assumed minimally 1).
Requires @frame_samples_min and @frame_samples_max to be the equal.

Note: This value will be reset to 0 every time before
GstAudioEncoder::set_format() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">number of frames</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_samples_max"
              c:identifier="gst_audio_encoder_set_frame_samples_max">
        <doc xml:space="preserve">Sets number of samples (per channel) subclass needs to be handed,
at most or will be handed all available if 0.

If an exact number of samples is required, gst_audio_encoder_set_frame_samples_min()
must be called with the same number.

Note: This value will be reset to 0 every time before
GstAudioEncoder::set_format() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">number of samples per frame</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_samples_min"
              c:identifier="gst_audio_encoder_set_frame_samples_min">
        <doc xml:space="preserve">Sets number of samples (per channel) subclass needs to be handed,
at least or will be handed all available if 0.

If an exact number of samples is required, gst_audio_encoder_set_frame_samples_max()
must be called with the same number.

Note: This value will be reset to 0 every time before
GstAudioEncoder::set_format() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">number of samples per frame</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hard_min"
              c:identifier="gst_audio_encoder_set_hard_min">
        <doc xml:space="preserve">Configures encoder hard minimum handling.  If enabled, subclass
will never be handed less samples than it configured, which otherwise
might occur near end-of-data handling.  Instead, the leftover samples
will simply be discarded.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_hard_resync"
              c:identifier="gst_audio_encoder_set_hard_resync">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_headers" c:identifier="gst_audio_encoder_set_headers">
        <doc xml:space="preserve">Set the codec headers to be sent downstream whenever requested.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="headers" transfer-ownership="full">
            <doc xml:space="preserve">a list of
  #GstBuffer containing the codec header</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Gst.Buffer"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency" c:identifier="gst_audio_encoder_set_latency">
        <doc xml:space="preserve">Sets encoder latency.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve">minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve">maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_lookahead"
              c:identifier="gst_audio_encoder_set_lookahead">
        <doc xml:space="preserve">Sets encoder lookahead (in units of input rate samples)

Note: This value will be reset to 0 every time before
GstAudioEncoder::set_format() is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="num" transfer-ownership="none">
            <doc xml:space="preserve">lookahead</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mark_granule"
              c:identifier="gst_audio_encoder_set_mark_granule">
        <doc xml:space="preserve">Enable or disable encoder granule handling.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_output_format"
              c:identifier="gst_audio_encoder_set_output_format">
        <doc xml:space="preserve">Configure output caps on the srcpad of @enc.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">#GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_perfect_timestamp"
              c:identifier="gst_audio_encoder_set_perfect_timestamp">
        <doc xml:space="preserve">Enable or disable encoder perfect output timestamp preference.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_tolerance"
              c:identifier="gst_audio_encoder_set_tolerance">
        <doc xml:space="preserve">Configures encoder audio jitter tolerance threshold.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enc" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioEncoder</doc>
            <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
          </instance-parameter>
          <parameter name="tolerance" transfer-ownership="none">
            <doc xml:space="preserve">new tolerance</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <property name="hard-resync" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mark-granule" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="perfect-timestamp"
                writable="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="tolerance" writable="1" transfer-ownership="none">
        <type name="gint64" c:type="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="stream_lock">
        <type name="GLib.RecMutex" c:type="GRecMutex"/>
      </field>
      <field name="input_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="output_segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AudioEncoderPrivate" c:type="GstAudioEncoderPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioEncoderClass"
            c:type="GstAudioEncoderClass"
            glib:is-gtype-struct-for="AudioEncoder">
      <doc xml:space="preserve">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @set_format and @handle_frame needs to be overridden.</doc>
      <field name="element_class">
        <doc xml:space="preserve">The parent class structure</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_format">
        <callback name="set_format">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AudioInfo" c:type="GstAudioInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_frame">
        <callback name="handle_frame">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="flush">
        <callback name="flush">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push">
        <callback name="pre_push">
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event">
        <callback name="sink_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="getcaps">
        <callback name="getcaps">
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="filter" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the negotiation succeeded, else %FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <doc xml:space="preserve">a #GstAudioEncoder</doc>
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decide_allocation">
        <callback name="decide_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="propose_allocation">
        <callback name="propose_allocation">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_meta">
        <callback name="transform_meta">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="enc" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="meta" transfer-ownership="none">
              <type name="Gst.Meta" c:type="GstMeta*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_query">
        <callback name="sink_query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="encoder" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_query">
        <callback name="src_query">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="encoder" transfer-ownership="none">
              <type name="AudioEncoder" c:type="GstAudioEncoder*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="17">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioEncoderPrivate"
            c:type="GstAudioEncoderPrivate"
            disguised="1">
    </record>
    <class name="AudioFilter"
           c:symbol-prefix="audio_filter"
           c:type="GstAudioFilter"
           parent="GstBase.BaseTransform"
           abstract="1"
           glib:type-name="GstAudioFilter"
           glib:get-type="gst_audio_filter_get_type"
           glib:type-struct="AudioFilterClass">
      <doc xml:space="preserve">#GstAudioFilter is a #GstBaseTransform&lt;!-- --&gt;-derived base class for simple audio
filters, ie. those that output the same format that they get as input.

#GstAudioFilter will parse the input format for you (with error checking)
before calling your setup function. Also, elements deriving from
#GstAudioFilter may use gst_audio_filter_class_add_pad_templates() from
their class_init function to easily configure the set of caps/formats that
the element is able to handle.

Derived classes should override the #GstAudioFilterClass.setup() and
#GstBaseTransformClass.transform_ip() and/or
#GstBaseTransformClass.transform()
virtual functions in their class_init function.</doc>
      <virtual-method name="setup">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="filter" transfer-ownership="none">
            <type name="AudioFilter" c:type="GstAudioFilter*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="basetransform">
        <type name="GstBase.BaseTransform" c:type="GstBaseTransform"/>
      </field>
      <field name="info">
        <type name="AudioInfo" c:type="GstAudioInfo"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioFilterClass"
            c:type="GstAudioFilterClass"
            glib:is-gtype-struct-for="AudioFilter">
      <doc xml:space="preserve">In addition to the @setup virtual function, you should also override the
GstBaseTransform::transform and/or GstBaseTransform::transform_ip virtual
function.</doc>
      <field name="basetransformclass">
        <doc xml:space="preserve">parent class</doc>
        <type name="GstBase.BaseTransformClass"
              c:type="GstBaseTransformClass"/>
      </field>
      <field name="setup">
        <callback name="setup">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="filter" transfer-ownership="none">
              <type name="AudioFilter" c:type="GstAudioFilter*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="AudioInfo" c:type="const GstAudioInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="add_pad_templates"
              c:identifier="gst_audio_filter_class_add_pad_templates">
        <doc xml:space="preserve">Convenience function to add pad templates to this element class, with
@allowed_caps as the caps that can be handled.

This function is usually used from within a GObject class_init function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="klass" transfer-ownership="none">
            <doc xml:space="preserve">an #GstAudioFilterClass</doc>
            <type name="AudioFilterClass" c:type="GstAudioFilterClass*"/>
          </instance-parameter>
          <parameter name="allowed_caps" transfer-ownership="none">
            <doc xml:space="preserve">what formats the filter can handle, as #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="AudioFlags"
              glib:type-name="GstAudioFlags"
              glib:get-type="gst_audio_flags_get_type"
              c:type="GstAudioFlags">
      <doc xml:space="preserve">Extra audio flags</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no valid flag</doc>
      </member>
      <member name="unpositioned"
              value="1"
              c:identifier="GST_AUDIO_FLAG_UNPOSITIONED"
              glib:nick="unpositioned">
        <doc xml:space="preserve">the position array explicitly
    contains unpositioned channels.</doc>
      </member>
    </bitfield>
    <enumeration name="AudioFormat"
                 glib:type-name="GstAudioFormat"
                 glib:get-type="gst_audio_format_get_type"
                 c:type="GstAudioFormat">
      <doc xml:space="preserve">Enum value describing the most common audio formats.</doc>
      <member name="unknown"
              value="0"
              c:identifier="GST_AUDIO_FORMAT_UNKNOWN"
              glib:nick="unknown">
        <doc xml:space="preserve">unknown or unset audio format</doc>
      </member>
      <member name="encoded"
              value="1"
              c:identifier="GST_AUDIO_FORMAT_ENCODED"
              glib:nick="encoded">
        <doc xml:space="preserve">encoded audio format</doc>
      </member>
      <member name="s8"
              value="2"
              c:identifier="GST_AUDIO_FORMAT_S8"
              glib:nick="s8">
        <doc xml:space="preserve">8 bits in 8 bits, signed</doc>
      </member>
      <member name="u8"
              value="3"
              c:identifier="GST_AUDIO_FORMAT_U8"
              glib:nick="u8">
        <doc xml:space="preserve">8 bits in 8 bits, unsigned</doc>
      </member>
      <member name="s16le"
              value="4"
              c:identifier="GST_AUDIO_FORMAT_S16LE"
              glib:nick="s16le">
        <doc xml:space="preserve">16 bits in 16 bits, signed, little endian</doc>
      </member>
      <member name="s16be"
              value="5"
              c:identifier="GST_AUDIO_FORMAT_S16BE"
              glib:nick="s16be">
        <doc xml:space="preserve">16 bits in 16 bits, signed, big endian</doc>
      </member>
      <member name="u16le"
              value="6"
              c:identifier="GST_AUDIO_FORMAT_U16LE"
              glib:nick="u16le">
        <doc xml:space="preserve">16 bits in 16 bits, unsigned, little endian</doc>
      </member>
      <member name="u16be"
              value="7"
              c:identifier="GST_AUDIO_FORMAT_U16BE"
              glib:nick="u16be">
        <doc xml:space="preserve">16 bits in 16 bits, unsigned, big endian</doc>
      </member>
      <member name="s24_32le"
              value="8"
              c:identifier="GST_AUDIO_FORMAT_S24_32LE"
              glib:nick="s24-32le">
        <doc xml:space="preserve">24 bits in 32 bits, signed, little endian</doc>
      </member>
      <member name="s24_32be"
              value="9"
              c:identifier="GST_AUDIO_FORMAT_S24_32BE"
              glib:nick="s24-32be">
        <doc xml:space="preserve">24 bits in 32 bits, signed, big endian</doc>
      </member>
      <member name="u24_32le"
              value="10"
              c:identifier="GST_AUDIO_FORMAT_U24_32LE"
              glib:nick="u24-32le">
        <doc xml:space="preserve">24 bits in 32 bits, unsigned, little endian</doc>
      </member>
      <member name="u24_32be"
              value="11"
              c:identifier="GST_AUDIO_FORMAT_U24_32BE"
              glib:nick="u24-32be">
        <doc xml:space="preserve">24 bits in 32 bits, unsigned, big endian</doc>
      </member>
      <member name="s32le"
              value="12"
              c:identifier="GST_AUDIO_FORMAT_S32LE"
              glib:nick="s32le">
        <doc xml:space="preserve">32 bits in 32 bits, signed, little endian</doc>
      </member>
      <member name="s32be"
              value="13"
              c:identifier="GST_AUDIO_FORMAT_S32BE"
              glib:nick="s32be">
        <doc xml:space="preserve">32 bits in 32 bits, signed, big endian</doc>
      </member>
      <member name="u32le"
              value="14"
              c:identifier="GST_AUDIO_FORMAT_U32LE"
              glib:nick="u32le">
        <doc xml:space="preserve">32 bits in 32 bits, unsigned, little endian</doc>
      </member>
      <member name="u32be"
              value="15"
              c:identifier="GST_AUDIO_FORMAT_U32BE"
              glib:nick="u32be">
        <doc xml:space="preserve">32 bits in 32 bits, unsigned, big endian</doc>
      </member>
      <member name="s24le"
              value="16"
              c:identifier="GST_AUDIO_FORMAT_S24LE"
              glib:nick="s24le">
        <doc xml:space="preserve">24 bits in 24 bits, signed, little endian</doc>
      </member>
      <member name="s24be"
              value="17"
              c:identifier="GST_AUDIO_FORMAT_S24BE"
              glib:nick="s24be">
        <doc xml:space="preserve">24 bits in 24 bits, signed, big endian</doc>
      </member>
      <member name="u24le"
              value="18"
              c:identifier="GST_AUDIO_FORMAT_U24LE"
              glib:nick="u24le">
        <doc xml:space="preserve">24 bits in 24 bits, unsigned, little endian</doc>
      </member>
      <member name="u24be"
              value="19"
              c:identifier="GST_AUDIO_FORMAT_U24BE"
              glib:nick="u24be">
        <doc xml:space="preserve">24 bits in 24 bits, unsigned, big endian</doc>
      </member>
      <member name="s20le"
              value="20"
              c:identifier="GST_AUDIO_FORMAT_S20LE"
              glib:nick="s20le">
        <doc xml:space="preserve">20 bits in 24 bits, signed, little endian</doc>
      </member>
      <member name="s20be"
              value="21"
              c:identifier="GST_AUDIO_FORMAT_S20BE"
              glib:nick="s20be">
        <doc xml:space="preserve">20 bits in 24 bits, signed, big endian</doc>
      </member>
      <member name="u20le"
              value="22"
              c:identifier="GST_AUDIO_FORMAT_U20LE"
              glib:nick="u20le">
        <doc xml:space="preserve">20 bits in 24 bits, unsigned, little endian</doc>
      </member>
      <member name="u20be"
              value="23"
              c:identifier="GST_AUDIO_FORMAT_U20BE"
              glib:nick="u20be">
        <doc xml:space="preserve">20 bits in 24 bits, unsigned, big endian</doc>
      </member>
      <member name="s18le"
              value="24"
              c:identifier="GST_AUDIO_FORMAT_S18LE"
              glib:nick="s18le">
        <doc xml:space="preserve">18 bits in 24 bits, signed, little endian</doc>
      </member>
      <member name="s18be"
              value="25"
              c:identifier="GST_AUDIO_FORMAT_S18BE"
              glib:nick="s18be">
        <doc xml:space="preserve">18 bits in 24 bits, signed, big endian</doc>
      </member>
      <member name="u18le"
              value="26"
              c:identifier="GST_AUDIO_FORMAT_U18LE"
              glib:nick="u18le">
        <doc xml:space="preserve">18 bits in 24 bits, unsigned, little endian</doc>
      </member>
      <member name="u18be"
              value="27"
              c:identifier="GST_AUDIO_FORMAT_U18BE"
              glib:nick="u18be">
        <doc xml:space="preserve">18 bits in 24 bits, unsigned, big endian</doc>
      </member>
      <member name="f32le"
              value="28"
              c:identifier="GST_AUDIO_FORMAT_F32LE"
              glib:nick="f32le">
        <doc xml:space="preserve">32-bit floating point samples, little endian</doc>
      </member>
      <member name="f32be"
              value="29"
              c:identifier="GST_AUDIO_FORMAT_F32BE"
              glib:nick="f32be">
        <doc xml:space="preserve">32-bit floating point samples, big endian</doc>
      </member>
      <member name="f64le"
              value="30"
              c:identifier="GST_AUDIO_FORMAT_F64LE"
              glib:nick="f64le">
        <doc xml:space="preserve">64-bit floating point samples, little endian</doc>
      </member>
      <member name="f64be"
              value="31"
              c:identifier="GST_AUDIO_FORMAT_F64BE"
              glib:nick="f64be">
        <doc xml:space="preserve">64-bit floating point samples, big endian</doc>
      </member>
      <member name="s16"
              value="4"
              c:identifier="GST_AUDIO_FORMAT_S16"
              glib:nick="s16">
        <doc xml:space="preserve">16 bits in 16 bits, signed, native endianness</doc>
      </member>
      <member name="u16"
              value="6"
              c:identifier="GST_AUDIO_FORMAT_U16"
              glib:nick="u16">
        <doc xml:space="preserve">16 bits in 16 bits, unsigned, native endianness</doc>
      </member>
      <member name="s24_32"
              value="8"
              c:identifier="GST_AUDIO_FORMAT_S24_32"
              glib:nick="s24-32">
        <doc xml:space="preserve">24 bits in 32 bits, signed, native endianness</doc>
      </member>
      <member name="u24_32"
              value="10"
              c:identifier="GST_AUDIO_FORMAT_U24_32"
              glib:nick="u24-32">
        <doc xml:space="preserve">24 bits in 32 bits, unsigned, native endianness</doc>
      </member>
      <member name="s32"
              value="12"
              c:identifier="GST_AUDIO_FORMAT_S32"
              glib:nick="s32">
        <doc xml:space="preserve">32 bits in 32 bits, signed, native endianness</doc>
      </member>
      <member name="u32"
              value="14"
              c:identifier="GST_AUDIO_FORMAT_U32"
              glib:nick="u32">
        <doc xml:space="preserve">32 bits in 32 bits, unsigned, native endianness</doc>
      </member>
      <member name="s24"
              value="16"
              c:identifier="GST_AUDIO_FORMAT_S24"
              glib:nick="s24">
        <doc xml:space="preserve">24 bits in 24 bits, signed, native endianness</doc>
      </member>
      <member name="u24"
              value="18"
              c:identifier="GST_AUDIO_FORMAT_U24"
              glib:nick="u24">
        <doc xml:space="preserve">24 bits in 24 bits, unsigned, native endianness</doc>
      </member>
      <member name="s20"
              value="20"
              c:identifier="GST_AUDIO_FORMAT_S20"
              glib:nick="s20">
        <doc xml:space="preserve">20 bits in 24 bits, signed, native endianness</doc>
      </member>
      <member name="u20"
              value="22"
              c:identifier="GST_AUDIO_FORMAT_U20"
              glib:nick="u20">
        <doc xml:space="preserve">20 bits in 24 bits, unsigned, native endianness</doc>
      </member>
      <member name="s18"
              value="24"
              c:identifier="GST_AUDIO_FORMAT_S18"
              glib:nick="s18">
        <doc xml:space="preserve">18 bits in 24 bits, signed, native endianness</doc>
      </member>
      <member name="u18"
              value="26"
              c:identifier="GST_AUDIO_FORMAT_U18"
              glib:nick="u18">
        <doc xml:space="preserve">18 bits in 24 bits, unsigned, native endianness</doc>
      </member>
      <member name="f32"
              value="28"
              c:identifier="GST_AUDIO_FORMAT_F32"
              glib:nick="f32">
        <doc xml:space="preserve">32-bit floating point samples, native endianness</doc>
      </member>
      <member name="f64"
              value="30"
              c:identifier="GST_AUDIO_FORMAT_F64"
              glib:nick="f64">
        <doc xml:space="preserve">64-bit floating point samples, native endianness</doc>
      </member>
      <function name="build_integer"
                c:identifier="gst_audio_format_build_integer">
        <doc xml:space="preserve">Construct a #GstAudioFormat with given parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormat or GST_AUDIO_FORMAT_UNKNOWN when no audio format
exists with the given parameters.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </return-value>
        <parameters>
          <parameter name="sign" transfer-ownership="none">
            <doc xml:space="preserve">signed or unsigned format</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="endianness" transfer-ownership="none">
            <doc xml:space="preserve">G_LITTLE_ENDIAN or G_BIG_ENDIAN</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">amount of bits used per sample</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve">amount of used bits in @width</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </function>
      <function name="fill_silence"
                c:identifier="gst_audio_format_fill_silence">
        <doc xml:space="preserve">Fill @length bytes in @dest with silence samples for @info.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
            <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
          </parameter>
          <parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">a destination
  to fill</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve">the length to fill</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="from_string" c:identifier="gst_audio_format_from_string">
        <doc xml:space="preserve">Convert the @format string to its #GstAudioFormat.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GstAudioFormat for @format or GST_AUDIO_FORMAT_UNKNOWN when the
string is not a known format.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a format string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_info" c:identifier="gst_audio_format_get_info">
        <doc xml:space="preserve">Get the #GstAudioFormatInfo for @format</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GstAudioFormatInfo for @format.</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioFormat</doc>
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="gst_audio_format_to_string">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <bitfield name="AudioFormatFlags"
              glib:type-name="GstAudioFormatFlags"
              glib:get-type="gst_audio_format_flags_get_type"
              c:type="GstAudioFormatFlags">
      <doc xml:space="preserve">The different audio flags that a format info can have.</doc>
      <member name="integer"
              value="1"
              c:identifier="GST_AUDIO_FORMAT_FLAG_INTEGER"
              glib:nick="integer">
        <doc xml:space="preserve">integer samples</doc>
      </member>
      <member name="float"
              value="2"
              c:identifier="GST_AUDIO_FORMAT_FLAG_FLOAT"
              glib:nick="float">
        <doc xml:space="preserve">float samples</doc>
      </member>
      <member name="signed"
              value="4"
              c:identifier="GST_AUDIO_FORMAT_FLAG_SIGNED"
              glib:nick="signed">
        <doc xml:space="preserve">signed samples</doc>
      </member>
      <member name="complex"
              value="16"
              c:identifier="GST_AUDIO_FORMAT_FLAG_COMPLEX"
              glib:nick="complex">
        <doc xml:space="preserve">complex layout</doc>
      </member>
      <member name="unpack"
              value="32"
              c:identifier="GST_AUDIO_FORMAT_FLAG_UNPACK"
              glib:nick="unpack">
        <doc xml:space="preserve">the format can be used in
#GstAudioFormatUnpack and #GstAudioFormatPack functions</doc>
      </member>
    </bitfield>
    <record name="AudioFormatInfo" c:type="GstAudioFormatInfo">
      <doc xml:space="preserve">Information for an audio format.</doc>
      <field name="format" writable="1">
        <doc xml:space="preserve">#GstAudioFormat</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve">string representation of the format</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="description" writable="1">
        <doc xml:space="preserve">user readable description of the format</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">#GstAudioFormatFlags</doc>
        <type name="AudioFormatFlags" c:type="GstAudioFormatFlags"/>
      </field>
      <field name="endianness" writable="1">
        <doc xml:space="preserve">the endianness</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve">amount of bits used for one sample</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="depth" writable="1">
        <doc xml:space="preserve">amount of valid bits in @width</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="silence" writable="1">
        <doc xml:space="preserve">@width/8 bytes with 1 silent sample</doc>
        <array zero-terminated="0" c:type="guint8" fixed-size="8">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="unpack_format" writable="1">
        <doc xml:space="preserve">the format of the unpacked samples</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </field>
      <field name="unpack_func" writable="1">
        <doc xml:space="preserve">function to unpack samples</doc>
        <type name="AudioFormatUnpack" c:type="GstAudioFormatUnpack"/>
      </field>
      <field name="pack_func" writable="1">
        <doc xml:space="preserve">function to pack samples</doc>
        <type name="AudioFormatPack" c:type="GstAudioFormatPack"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="AudioFormatPack" c:type="GstAudioFormatPack">
      <doc xml:space="preserve">Packs @length samples from @src to the data array in format @info.
The samples from source have each channel interleaved
and will be packed into @data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="AudioPackFlags" c:type="GstAudioPackFlags"/>
        </parameter>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">a source array</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the destination
  data</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the amount of samples to pack.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="AudioFormatUnpack" c:type="GstAudioFormatUnpack">
      <doc xml:space="preserve">Unpacks @length samples from the given data of format @info.
The samples will be unpacked into @dest which each channel
interleaved. @dest should at least be big enough to hold @length *
channels * size(unpack_format) bytes.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="AudioPackFlags" c:type="GstAudioPackFlags"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">a destination array</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">pointer to the audio data</doc>
          <array zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the amount of samples to unpack.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AudioInfo"
            c:type="GstAudioInfo"
            glib:type-name="GstAudioInfo"
            glib:get-type="gst_audio_info_get_type"
            c:symbol-prefix="audio_info">
      <doc xml:space="preserve">Information describing audio properties. This information can be filled
in from GstCaps with gst_audio_info_from_caps().

Use the provided macros to access the info in this structure.</doc>
      <field name="finfo" writable="1">
        <doc xml:space="preserve">the format info of the audio</doc>
        <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve">additional audio flags</doc>
        <type name="AudioFlags" c:type="GstAudioFlags"/>
      </field>
      <field name="layout" writable="1">
        <doc xml:space="preserve">audio layout</doc>
        <type name="AudioLayout" c:type="GstAudioLayout"/>
      </field>
      <field name="rate" writable="1">
        <doc xml:space="preserve">the audio sample rate</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="channels" writable="1">
        <doc xml:space="preserve">the number of channels</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="bpf" writable="1">
        <doc xml:space="preserve">the number of bytes for one frame, this is the size of one
        sample * @channels</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="position" writable="1">
        <doc xml:space="preserve">the positions for each channel</doc>
        <array zero-terminated="0"
               c:type="GstAudioChannelPosition"
               fixed-size="64">
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition"/>
        </array>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gst_audio_info_new">
        <doc xml:space="preserve">Allocate a new #GstAudioInfo that is also initialized with
gst_audio_info_init().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstAudioInfo. free with gst_audio_info_free().</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
      </constructor>
      <method name="convert" c:identifier="gst_audio_info_convert">
        <doc xml:space="preserve">Converts among various #GstFormat types.  This function handles
GST_FORMAT_BYTES, GST_FORMAT_TIME, and GST_FORMAT_DEFAULT.  For
raw audio, GST_FORMAT_DEFAULT corresponds to audio frames.  This
function can be used to handle pad queries of the type GST_QUERY_CONVERT.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the conversion was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="src_fmt" transfer-ownership="none">
            <doc xml:space="preserve">#GstFormat of the @src_val</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:space="preserve">value to convert</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_fmt" transfer-ownership="none">
            <doc xml:space="preserve">#GstFormat of the @dest_val</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">pointer to destination value</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gst_audio_info_copy">
        <doc xml:space="preserve">Copy a GstAudioInfo structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstAudioInfo. free with gst_audio_info_free.</doc>
          <type name="AudioInfo" c:type="GstAudioInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_audio_info_free">
        <doc xml:space="preserve">Free a GstAudioInfo structure previously allocated with gst_audio_info_new()
or gst_audio_info_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="from_caps" c:identifier="gst_audio_info_from_caps">
        <doc xml:space="preserve">Parse @caps and update @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if @caps could be parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_audio_info_init">
        <doc xml:space="preserve">Initialize @info with default values.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_equal"
              c:identifier="gst_audio_info_is_equal"
              version="1.2">
        <doc xml:space="preserve">Compares two #GstAudioInfo and returns whether they are equal or not</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @info and @other are equal, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="other" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_format" c:identifier="gst_audio_info_set_format">
        <doc xml:space="preserve">Set the default info for the audio info of @format and @rate and @channels.

Note: This initializes @info first, no values are preserved.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="GstAudioInfo*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format</doc>
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:space="preserve">the samplerate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">the number of channels</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="position"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the channel positions</doc>
            <array zero-terminated="0"
                   c:type="GstAudioChannelPosition*"
                   fixed-size="64">
              <type name="AudioChannelPosition"
                    c:type="GstAudioChannelPosition"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="to_caps" c:identifier="gst_audio_info_to_caps">
        <doc xml:space="preserve">Convert the values of @info into a #GstCaps.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #GstCaps containing the
         info of @info.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioInfo</doc>
            <type name="AudioInfo" c:type="const GstAudioInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="AudioLayout"
                 glib:type-name="GstAudioLayout"
                 glib:get-type="gst_audio_layout_get_type"
                 c:type="GstAudioLayout">
      <doc xml:space="preserve">Layout of the audio samples for the different channels.</doc>
      <member name="interleaved"
              value="0"
              c:identifier="GST_AUDIO_LAYOUT_INTERLEAVED"
              glib:nick="interleaved">
        <doc xml:space="preserve">interleaved audio</doc>
      </member>
      <member name="non_interleaved"
              value="1"
              c:identifier="GST_AUDIO_LAYOUT_NON_INTERLEAVED"
              glib:nick="non-interleaved">
        <doc xml:space="preserve">non-interleaved audio</doc>
      </member>
    </enumeration>
    <enumeration name="AudioNoiseShapingMethod"
                 glib:type-name="GstAudioNoiseShapingMethod"
                 glib:get-type="gst_audio_noise_shaping_method_get_type"
                 c:type="GstAudioNoiseShapingMethod">
      <doc xml:space="preserve">Set of available noise shaping methods</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_NOISE_SHAPING_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No noise shaping (default)</doc>
      </member>
      <member name="error_feedback"
              value="1"
              c:identifier="GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK"
              glib:nick="error-feedback">
        <doc xml:space="preserve">Error feedback</doc>
      </member>
      <member name="simple"
              value="2"
              c:identifier="GST_AUDIO_NOISE_SHAPING_SIMPLE"
              glib:nick="simple">
        <doc xml:space="preserve">Simple 2-pole noise shaping</doc>
      </member>
      <member name="medium"
              value="3"
              c:identifier="GST_AUDIO_NOISE_SHAPING_MEDIUM"
              glib:nick="medium">
        <doc xml:space="preserve">Medium 5-pole noise shaping</doc>
      </member>
      <member name="high"
              value="4"
              c:identifier="GST_AUDIO_NOISE_SHAPING_HIGH"
              glib:nick="high">
        <doc xml:space="preserve">High 8-pole noise shaping</doc>
      </member>
    </enumeration>
    <bitfield name="AudioPackFlags"
              glib:type-name="GstAudioPackFlags"
              glib:get-type="gst_audio_pack_flags_get_type"
              c:type="GstAudioPackFlags">
      <doc xml:space="preserve">The different flags that can be used when packing and unpacking.</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_PACK_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No flag</doc>
      </member>
      <member name="truncate_range"
              value="1"
              c:identifier="GST_AUDIO_PACK_FLAG_TRUNCATE_RANGE"
              glib:nick="truncate-range">
        <doc xml:space="preserve">When the source has a smaller depth
  than the target format, set the least significant bits of the target
  to 0. This is likely sightly faster but less accurate. When this flag
  is not specified, the most significant bits of the source are duplicated
  in the least significant bits of the destination.</doc>
      </member>
    </bitfield>
    <record name="AudioQuantize" c:type="GstAudioQuantize" disguised="1">
      <method name="free" c:identifier="gst_audio_quantize_free">
        <doc xml:space="preserve">Free a #GstAudioQuantize.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quant" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioQuantize</doc>
            <type name="AudioQuantize" c:type="GstAudioQuantize*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gst_audio_quantize_reset">
        <doc xml:space="preserve">Reset @quant to the state is was when created, clearing any
history it might have.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quant" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioQuantize</doc>
            <type name="AudioQuantize" c:type="GstAudioQuantize*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="samples" c:identifier="gst_audio_quantize_samples">
        <doc xml:space="preserve">Perform quantization on @samples in @in and write the result to @out.

In case the samples are interleaved, @in and @out must point to an
array with a single element pointing to a block of interleaved samples.

If non-interleaved samples are used, @in and @out must point to an
array with pointers to memory blocks, one for each channel.

@in and @out may point to the same memory location, in which case samples will be
modified in-place.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quant" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioQuantize</doc>
            <type name="AudioQuantize" c:type="GstAudioQuantize*"/>
          </instance-parameter>
          <parameter name="in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">input samples</doc>
            <type name="gpointer" c:type="const gpointer"/>
          </parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">output samples</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="samples" transfer-ownership="none">
            <doc xml:space="preserve">number of samples</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_audio_quantize_new"
                introspectable="0">
        <doc xml:space="preserve">Create a new quantizer object with the given parameters.

Output samples will be quantized to a multiple of @quantizer. Better
performance is achieved when @quantizer is a power of 2.

Dithering and noise-shaping can be performed during quantization with
the @dither and @ns parameters.</doc>
        <return-value>
          <doc xml:space="preserve">a new #GstAudioQuantize. Free with gst_audio_quantize_free().</doc>
          <type name="AudioQuantize" c:type="GstAudioQuantize*"/>
        </return-value>
        <parameters>
          <parameter name="dither" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioDitherMethod</doc>
            <type name="AudioDitherMethod" c:type="GstAudioDitherMethod"/>
          </parameter>
          <parameter name="ns" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioNoiseShapingMethod</doc>
            <type name="AudioNoiseShapingMethod"
                  c:type="GstAudioNoiseShapingMethod"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GstAudioQuantizeFlags</doc>
            <type name="AudioQuantizeFlags" c:type="GstAudioQuantizeFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioFormat of the samples</doc>
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <doc xml:space="preserve">the amount of channels in the samples</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="quantizer" transfer-ownership="none">
            <doc xml:space="preserve">the quantizer to use</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="AudioQuantizeFlags"
              glib:type-name="GstAudioQuantizeFlags"
              glib:get-type="gst_audio_quantize_flags_get_type"
              c:type="GstAudioQuantizeFlags">
      <doc xml:space="preserve">Extra flags that can be passed to gst_audio_quantize_new()</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_QUANTIZE_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flags</doc>
      </member>
      <member name="non_interleaved"
              value="1"
              c:identifier="GST_AUDIO_QUANTIZE_FLAG_NON_INTERLEAVED"
              glib:nick="non-interleaved">
        <doc xml:space="preserve">samples are non-interleaved</doc>
      </member>
    </bitfield>
    <record name="AudioResampler" c:type="GstAudioResampler" disguised="1">
      <doc xml:space="preserve">#GstAudioResampler is a structure which holds the information
required to perform various kinds of resampling filtering.</doc>
      <method name="free"
              c:identifier="gst_audio_resampler_free"
              version="1.6">
        <doc xml:space="preserve">Free a previously allocated #GstAudioResampler @resampler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resampler" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResampler</doc>
            <type name="AudioResampler" c:type="GstAudioResampler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_in_frames"
              c:identifier="gst_audio_resampler_get_in_frames">
        <doc xml:space="preserve">Get the number of input frames that would currently be needed
to produce @out_frames from @resampler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of input frames needed for producing
@out_frames of data from @resampler.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="resampler" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResampler</doc>
            <type name="AudioResampler" c:type="GstAudioResampler*"/>
          </instance-parameter>
          <parameter name="out_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of input frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_max_latency"
              c:identifier="gst_audio_resampler_get_max_latency">
        <doc xml:space="preserve">Get the maximum number of input samples that the resampler would
need before producing output.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the latency of @resampler as expressed in the number of
frames.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="resampler" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResampler</doc>
            <type name="AudioResampler" c:type="GstAudioResampler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_out_frames"
              c:identifier="gst_audio_resampler_get_out_frames">
        <doc xml:space="preserve">Get the number of output frames that would be currently available when
@in_frames are given to @resampler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of frames that would be availabe after giving
@in_frames as input to @resampler.</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="resampler" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResampler</doc>
            <type name="AudioResampler" c:type="GstAudioResampler*"/>
          </instance-parameter>
          <parameter name="in_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of input frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="resample" c:identifier="gst_audio_resampler_resample">
        <doc xml:space="preserve">Perform resampling on @in_frames frames in @in and write @out_frames to @out.

In case the samples are interleaved, @in and @out must point to an
array with a single element pointing to a block of interleaved samples.

If non-interleaved samples are used, @in and @out must point to an
array with pointers to memory blocks, one for each channel.

@in may be %NULL, in which case @in_frames of silence samples are pushed
into the resampler.

This function always produces @out_frames of output and consumes @in_frames of
input. Use gst_audio_resampler_get_out_frames() and
gst_audio_resampler_get_in_frames() to make sure @in_frames and @out_frames
are matching and @in and @out point to enough memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resampler" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResampler</doc>
            <type name="AudioResampler" c:type="GstAudioResampler*"/>
          </instance-parameter>
          <parameter name="in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">input samples</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="in_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of input frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">output samples</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="out_frames" transfer-ownership="none">
            <doc xml:space="preserve">number of output frames</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gst_audio_resampler_reset">
        <doc xml:space="preserve">Reset @resampler to the state it was when it was first created, discarding
all sample history.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="resampler" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResampler</doc>
            <type name="AudioResampler" c:type="GstAudioResampler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update" c:identifier="gst_audio_resampler_update">
        <doc xml:space="preserve">Update the resampler parameters for @resampler. This function should
not be called concurrently with any other function on @resampler.

When @in_rate or @out_rate is 0, its value is unchanged.

When @options is %NULL, the previously configured options are reused.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the new parameters could be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resampler" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResampler</doc>
            <type name="AudioResampler" c:type="GstAudioResampler*"/>
          </instance-parameter>
          <parameter name="in_rate" transfer-ownership="none">
            <doc xml:space="preserve">new input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_rate" transfer-ownership="none">
            <doc xml:space="preserve">new output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">new options or %NULL</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="gst_audio_resampler_new">
        <doc xml:space="preserve">Make a new resampler.</doc>
        <return-value transfer-ownership="full" skip="1">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="AudioResampler" c:type="GstAudioResampler*"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResamplerMethod</doc>
            <type name="AudioResamplerMethod"
                  c:type="GstAudioResamplerMethod"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">#GstAudioResamplerFlags</doc>
            <type name="AudioResamplerFlags" c:type="GstAudioResamplerFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="AudioFormat" c:type="GstAudioFormat"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="in_rate" transfer-ownership="none">
            <doc xml:space="preserve">input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_rate" transfer-ownership="none">
            <doc xml:space="preserve">output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">extra options</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </function>
      <function name="options_set_quality"
                c:identifier="gst_audio_resampler_options_set_quality">
        <doc xml:space="preserve">Set the parameters for resampling from @in_rate to @out_rate using @method
for @quality in @options.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="method" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioResamplerMethod</doc>
            <type name="AudioResamplerMethod"
                  c:type="GstAudioResamplerMethod"/>
          </parameter>
          <parameter name="quality" transfer-ownership="none">
            <doc xml:space="preserve">the quality</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="in_rate" transfer-ownership="none">
            <doc xml:space="preserve">the input rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_rate" transfer-ownership="none">
            <doc xml:space="preserve">the output rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="options" transfer-ownership="none">
            <doc xml:space="preserve">a #GstStructure</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="AudioResamplerFilterInterpolation"
                 glib:type-name="GstAudioResamplerFilterInterpolation"
                 glib:get-type="gst_audio_resampler_filter_interpolation_get_type"
                 c:type="GstAudioResamplerFilterInterpolation">
      <doc xml:space="preserve">The different filter interpolation methods.</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no interpolation</doc>
      </member>
      <member name="linear"
              value="1"
              c:identifier="GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_LINEAR"
              glib:nick="linear">
        <doc xml:space="preserve">linear interpolation of the
  filter coeficients.</doc>
      </member>
      <member name="cubic"
              value="2"
              c:identifier="GST_AUDIO_RESAMPLER_FILTER_INTERPOLATION_CUBIC"
              glib:nick="cubic">
        <doc xml:space="preserve">cubic interpolation of the
  filter coeficients.</doc>
      </member>
    </enumeration>
    <enumeration name="AudioResamplerFilterMode"
                 glib:type-name="GstAudioResamplerFilterMode"
                 glib:get-type="gst_audio_resampler_filter_mode_get_type"
                 c:type="GstAudioResamplerFilterMode">
      <doc xml:space="preserve">Select for the filter tables should be set up.</doc>
      <member name="interpolated"
              value="0"
              c:identifier="GST_AUDIO_RESAMPLER_FILTER_MODE_INTERPOLATED"
              glib:nick="interpolated">
        <doc xml:space="preserve">Use interpolated filter tables. This
    uses less memory but more CPU and is slightly less accurate but it allows for more
    efficient variable rate resampling with gst_audio_resampler_update().</doc>
      </member>
      <member name="full"
              value="1"
              c:identifier="GST_AUDIO_RESAMPLER_FILTER_MODE_FULL"
              glib:nick="full">
        <doc xml:space="preserve">Use full filter table. This uses more memory
    but less CPU.</doc>
      </member>
      <member name="auto"
              value="2"
              c:identifier="GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO"
              glib:nick="auto">
        <doc xml:space="preserve">Automatically choose between interpolated
    and full filter tables.</doc>
      </member>
    </enumeration>
    <bitfield name="AudioResamplerFlags"
              glib:type-name="GstAudioResamplerFlags"
              glib:get-type="gst_audio_resampler_flags_get_type"
              c:type="GstAudioResamplerFlags">
      <doc xml:space="preserve">Different resampler flags.</doc>
      <member name="none"
              value="0"
              c:identifier="GST_AUDIO_RESAMPLER_FLAG_NONE"
              glib:nick="none">
        <doc xml:space="preserve">no flags</doc>
      </member>
      <member name="non_interleaved_in"
              value="1"
              c:identifier="GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN"
              glib:nick="non-interleaved-in">
        <doc xml:space="preserve">input samples are non-interleaved.
   an array of blocks of samples, one for each channel, should be passed to the
   resample function.</doc>
      </member>
      <member name="non_interleaved_out"
              value="2"
              c:identifier="GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT"
              glib:nick="non-interleaved-out">
        <doc xml:space="preserve">output samples are non-interleaved.
   an array of blocks of samples, one for each channel, should be passed to the
   resample function.</doc>
      </member>
      <member name="variable_rate"
              value="4"
              c:identifier="GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE"
              glib:nick="variable-rate">
        <doc xml:space="preserve">optimize for dynamic updates of the sample
   rates with gst_audio_resampler_update(). This will select an interpolating filter
   when #GST_AUDIO_RESAMPLER_FILTER_MODE_AUTO is configured.</doc>
      </member>
    </bitfield>
    <enumeration name="AudioResamplerMethod"
                 version="1.6"
                 glib:type-name="GstAudioResamplerMethod"
                 glib:get-type="gst_audio_resampler_method_get_type"
                 c:type="GstAudioResamplerMethod">
      <doc xml:space="preserve">Different subsampling and upsampling methods</doc>
      <member name="nearest"
              value="0"
              c:identifier="GST_AUDIO_RESAMPLER_METHOD_NEAREST"
              glib:nick="nearest">
        <doc xml:space="preserve">Duplicates the samples when
   upsampling and drops when downsampling</doc>
      </member>
      <member name="linear"
              value="1"
              c:identifier="GST_AUDIO_RESAMPLER_METHOD_LINEAR"
              glib:nick="linear">
        <doc xml:space="preserve">Uses linear interpolation to reconstruct
   missing samples and averaging to downsample</doc>
      </member>
      <member name="cubic"
              value="2"
              c:identifier="GST_AUDIO_RESAMPLER_METHOD_CUBIC"
              glib:nick="cubic">
        <doc xml:space="preserve">Uses cubic interpolation</doc>
      </member>
      <member name="blackman_nuttall"
              value="3"
              c:identifier="GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL"
              glib:nick="blackman-nuttall">
        <doc xml:space="preserve">Uses Blackman-Nuttall windowed sinc interpolation</doc>
      </member>
      <member name="kaiser"
              value="4"
              c:identifier="GST_AUDIO_RESAMPLER_METHOD_KAISER"
              glib:nick="kaiser">
        <doc xml:space="preserve">Uses Kaiser windowed sinc interpolation</doc>
      </member>
    </enumeration>
    <class name="AudioRingBuffer"
           c:symbol-prefix="audio_ring_buffer"
           c:type="GstAudioRingBuffer"
           parent="Gst.Object"
           abstract="1"
           glib:type-name="GstAudioRingBuffer"
           glib:get-type="gst_audio_ring_buffer_get_type"
           glib:type-struct="AudioRingBufferClass">
      <doc xml:space="preserve">This object is the base class for audio ringbuffers used by the base
audio source and sink classes.

The ringbuffer abstracts a circular buffer of data. One reader and
one writer can operate on the data from different threads in a lockfree
manner. The base class is sufficiently flexible to be used as an
abstraction for DMA based ringbuffers as well as a pure software
implementations.</doc>
      <function name="debug_spec_buff"
                c:identifier="gst_audio_ring_buffer_debug_spec_buff">
        <doc xml:space="preserve">Print debug info about the buffer sized in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the spec to debug</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="debug_spec_caps"
                c:identifier="gst_audio_ring_buffer_debug_spec_caps">
        <doc xml:space="preserve">Print debug info about the parsed caps in @spec to the debug log.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the spec to debug</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </function>
      <function name="parse_caps"
                c:identifier="gst_audio_ring_buffer_parse_caps">
        <doc xml:space="preserve">Parse @caps into @spec.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the caps could be parsed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">a spec</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="acquire" invoker="acquire">
        <doc xml:space="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be acquired, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to acquire</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the specs of the buffer</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="activate" invoker="activate">
        <doc xml:space="preserve">Activate @buf to start or stop pulling data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be activated in the requested mode,
FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to activate</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:space="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear_all" invoker="clear_all">
        <doc xml:space="preserve">Fill the ringbuffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="close_device" invoker="close_device">
        <doc xml:space="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_audio_ring_buffer_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be closed, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="commit" invoker="commit">
        <doc xml:space="preserve">Commit @in_samples samples pointed to by @data to the ringbuffer @buf.

@in_samples and @out_samples define the rate conversion to perform on the
samples in @data. For negative rates, @out_samples must be negative and
@in_samples positive.

When @out_samples is positive, the first sample will be written at position @sample
in the ringbuffer. When @out_samples is negative, the last sample will be written to
@sample in reverse order.

@out_samples does not need to be a multiple of the segment size of the ringbuffer
although it is recommended for optimal performance.

@accum will hold a temporary accumulator used in rate conversion and should be
set to 0 when this function is first called. In case the commit operation is
interrupted, one can resume the processing by passing the previously returned
@accum value back to this function.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples written to the ringbuffer or -1 on error. The
number of samples written can be less than @out_samples when @buf was interrupted
with a flush or stop.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to commit</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the data to commit</doc>
            <array length="2" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples in the data to commit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples to write to the ringbuffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">accumulator for rate conversion.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay" invoker="delay">
        <doc xml:space="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.

For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.

For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples queued in the audio device.

MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open_device" invoker="open_device">
        <doc xml:space="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be opened, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pause" invoker="pause">
        <doc xml:space="preserve">Pause processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be paused, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to pause</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="release" invoker="release">
        <doc xml:space="preserve">Free the resources of the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be released, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to release</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="resume">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start" invoker="start">
        <doc xml:space="preserve">Start processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be started, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to start</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop" invoker="stop">
        <doc xml:space="preserve">Stop processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be stopped, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to stop</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="acquire" c:identifier="gst_audio_ring_buffer_acquire">
        <doc xml:space="preserve">Allocate the resources for the ringbuffer. This function fills
in the data pointer of the ring buffer with a valid #GstBuffer
to which samples can be written.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be acquired, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to acquire</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <doc xml:space="preserve">the specs of the buffer</doc>
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="activate" c:identifier="gst_audio_ring_buffer_activate">
        <doc xml:space="preserve">Activate @buf to start or stop pulling data.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be activated in the requested mode,
FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to activate</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <doc xml:space="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="advance" c:identifier="gst_audio_ring_buffer_advance">
        <doc xml:space="preserve">Subclasses should call this function to notify the fact that
@advance segments are now processed by the device.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to advance</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="advance" transfer-ownership="none">
            <doc xml:space="preserve">the number of segments written</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gst_audio_ring_buffer_clear">
        <doc xml:space="preserve">Clear the given segment of the buffer with silence samples.
This function is used by subclasses.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve">the segment to clear</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_all" c:identifier="gst_audio_ring_buffer_clear_all">
        <doc xml:space="preserve">Fill the ringbuffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close_device"
              c:identifier="gst_audio_ring_buffer_close_device">
        <doc xml:space="preserve">Close the audio device associated with the ring buffer. The ring buffer
should already have been released via gst_audio_ring_buffer_release().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be closed, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="commit" c:identifier="gst_audio_ring_buffer_commit">
        <doc xml:space="preserve">Commit @in_samples samples pointed to by @data to the ringbuffer @buf.

@in_samples and @out_samples define the rate conversion to perform on the
samples in @data. For negative rates, @out_samples must be negative and
@in_samples positive.

When @out_samples is positive, the first sample will be written at position @sample
in the ringbuffer. When @out_samples is negative, the last sample will be written to
@sample in reverse order.

@out_samples does not need to be a multiple of the segment size of the ringbuffer
although it is recommended for optimal performance.

@accum will hold a temporary accumulator used in rate conversion and should be
set to 0 when this function is first called. In case the commit operation is
interrupted, one can resume the processing by passing the previously returned
@accum value back to this function.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples written to the ringbuffer or -1 on error. The
number of samples written can be less than @out_samples when @buf was interrupted
with a flush or stop.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to commit</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">the data to commit</doc>
            <array length="2" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="in_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples in the data to commit</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="out_samples" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples to write to the ringbuffer</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="accum"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">accumulator for rate conversion.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="convert" c:identifier="gst_audio_ring_buffer_convert">
        <doc xml:space="preserve">Convert @src_val in @src_fmt to the equivalent value in @dest_fmt. The result
will be put in @dest_val.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the conversion succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="src_fmt" transfer-ownership="none">
            <doc xml:space="preserve">the source format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_val" transfer-ownership="none">
            <doc xml:space="preserve">the source value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_fmt" transfer-ownership="none">
            <doc xml:space="preserve">the destination format</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a location to store the converted value</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delay" c:identifier="gst_audio_ring_buffer_delay">
        <doc xml:space="preserve">Get the number of samples queued in the audio device. This is
usually less than the segment size but can be bigger when the
implementation uses another internal buffer between the audio
device.

For playback ringbuffers this is the amount of samples transfered from the
ringbuffer to the device but still not played.

For capture ringbuffers this is the amount of samples in the device that are
not yet transfered to the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples queued in the audio device.

MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="device_is_open"
              c:identifier="gst_audio_ring_buffer_device_is_open">
        <doc xml:space="preserve">Checks the status of the device associated with the ring buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device was open, FALSE if it was closed.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_acquired"
              c:identifier="gst_audio_ring_buffer_is_acquired">
        <doc xml:space="preserve">Check if the ringbuffer is acquired and ready to use.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the ringbuffer is acquired, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to check</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_active" c:identifier="gst_audio_ring_buffer_is_active">
        <doc xml:space="preserve">Check if @buf is activated.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device is active.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_flushing"
              c:identifier="gst_audio_ring_buffer_is_flushing">
        <doc xml:space="preserve">Check if @buf is flushing.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device is flushing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="may_start" c:identifier="gst_audio_ring_buffer_may_start">
        <doc xml:space="preserve">Tell the ringbuffer that it is allowed to start playback when
the ringbuffer is filled with samples.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="allowed" transfer-ownership="none">
            <doc xml:space="preserve">the new value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="open_device"
              c:identifier="gst_audio_ring_buffer_open_device">
        <doc xml:space="preserve">Open the audio device associated with the ring buffer. Does not perform any
setup on the device. You must open the device before acquiring the ring
buffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be opened, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pause" c:identifier="gst_audio_ring_buffer_pause">
        <doc xml:space="preserve">Pause processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be paused, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to pause</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prepare_read"
              c:identifier="gst_audio_ring_buffer_prepare_read">
        <doc xml:space="preserve">Returns a pointer to memory where the data from segment @segment
can be found. This function is mostly used by subclasses.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">FALSE if the buffer is not started.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to read from</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="segment"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the segment to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="readptr"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">
    the pointer to the memory where samples can be read</doc>
            <array length="2" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
          <parameter name="len"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the number of bytes to read</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read" c:identifier="gst_audio_ring_buffer_read">
        <doc xml:space="preserve">Read @len samples from the ringbuffer into the memory pointed
to by @data.
The first sample should be read from position @sample in
the ringbuffer.

@len should not be a multiple of the segment size of the ringbuffer
although it is recommended.

@timestamp will return the timestamp associated with the data returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples read from the ringbuffer or -1 on
error.

MT safe.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to read from</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample position of the data</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve">where the data should be read</doc>
            <array length="2" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <doc xml:space="preserve">the number of samples in data to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">where the timestamp is returned</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="release" c:identifier="gst_audio_ring_buffer_release">
        <doc xml:space="preserve">Free the resources of the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be released, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to release</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="samples_done"
              c:identifier="gst_audio_ring_buffer_samples_done">
        <doc xml:space="preserve">Get the number of samples that were processed by the ringbuffer
since it was last started. This does not include the number of samples not
yet processed (see gst_audio_ring_buffer_delay()).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples processed by the ringbuffer.

MT safe.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_callback"
              c:identifier="gst_audio_ring_buffer_set_callback"
              shadowed-by="set_callback_full"
              introspectable="0">
        <doc xml:space="preserve">Sets the given callback function on the buffer. This function
will be called every time a segment has been written to a device.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to set the callback on</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="cb"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="1">
            <doc xml:space="preserve">the callback to set</doc>
            <type name="AudioRingBufferCallback"
                  c:type="GstAudioRingBufferCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_callback_full"
              c:identifier="gst_audio_ring_buffer_set_callback_full"
              shadows="set_callback"
              version="1.12">
        <doc xml:space="preserve">Sets the given callback function on the buffer. This function
will be called every time a segment has been written to a device.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to set the callback on</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="cb"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve">the callback to set</doc>
            <type name="AudioRingBufferCallback"
                  c:type="GstAudioRingBufferCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="notify" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to be called when @user_data is no longer needed</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_channel_positions"
              c:identifier="gst_audio_ring_buffer_set_channel_positions">
        <doc xml:space="preserve">Tell the ringbuffer about the device's channel positions. This must
be called in when the ringbuffer is acquired.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="position" transfer-ownership="none">
            <doc xml:space="preserve">the device channel positions</doc>
            <array zero-terminated="0" c:type="GstAudioChannelPosition*">
              <type name="AudioChannelPosition"
                    c:type="GstAudioChannelPosition"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_audio_ring_buffer_set_flushing">
        <doc xml:space="preserve">Set the ringbuffer to flushing mode or normal mode.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to flush</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:space="preserve">the new mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample"
              c:identifier="gst_audio_ring_buffer_set_sample">
        <doc xml:space="preserve">Make sure that the next sample written to the device is
accounted for as being the @sample sample written to the
device. This value will be used in reporting the current
sample position of the ringbuffer.

This function will also clear the buffer with silence.

MT safe.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to use</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="sample" transfer-ownership="none">
            <doc xml:space="preserve">the sample number to set</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timestamp"
              c:identifier="gst_audio_ring_buffer_set_timestamp">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
          <parameter name="readseg" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_audio_ring_buffer_start">
        <doc xml:space="preserve">Start processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be started, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to start</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="gst_audio_ring_buffer_stop">
        <doc xml:space="preserve">Stop processing samples from the ringbuffer.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the device could be stopped, FALSE on error.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve">the #GstAudioRingBuffer to stop</doc>
            <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="cond">
        <doc xml:space="preserve">used to signal start/stop/pause/resume actions</doc>
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <field name="open">
        <doc xml:space="preserve">boolean indicating that the ringbuffer is open</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="acquired">
        <doc xml:space="preserve">boolean indicating that the ringbuffer is acquired</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="memory">
        <doc xml:space="preserve">data in the ringbuffer</doc>
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="size">
        <doc xml:space="preserve">size of data in the ringbuffer</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="timestamps">
        <type name="Gst.ClockTime" c:type="GstClockTime*"/>
      </field>
      <field name="spec">
        <doc xml:space="preserve">format and layout of the ringbuffer data</doc>
        <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec"/>
      </field>
      <field name="samples_per_seg">
        <doc xml:space="preserve">number of samples in one segment</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="empty_seg">
        <doc xml:space="preserve">pointer to memory holding one segment of silence samples</doc>
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="state">
        <doc xml:space="preserve">state of the buffer</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segdone">
        <doc xml:space="preserve">readpointer in the ringbuffer</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segbase">
        <doc xml:space="preserve">segment corresponding to segment 0 (unused)</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="waiting">
        <doc xml:space="preserve">is a reader or writer waiting for a free segment</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="callback" readable="0" private="1">
        <type name="AudioRingBufferCallback"
              c:type="GstAudioRingBufferCallback"/>
      </field>
      <field name="cb_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="need_reorder" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="channel_reorder_map" readable="0" private="1">
        <array zero-terminated="0" c:type="gint" fixed-size="64">
          <type name="gint" c:type="gint"/>
        </array>
      </field>
      <field name="flushing" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="may_start" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="active" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="cb_data_notify" readable="0" private="1">
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="3">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <callback name="AudioRingBufferCallback"
              c:type="GstAudioRingBufferCallback">
      <doc xml:space="preserve">This function is set with gst_audio_ring_buffer_set_callback() and is
called to fill the memory at @data with @len bytes of samples.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="rbuf" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioRingBuffer</doc>
          <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">target to fill</doc>
          <array length="2" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="len" transfer-ownership="none">
          <doc xml:space="preserve">amount to fill</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="AudioRingBufferClass"
            c:type="GstAudioRingBufferClass"
            glib:is-gtype-struct-for="AudioRingBuffer">
      <doc xml:space="preserve">The vmethods that subclasses can override to implement the ringbuffer.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent class</doc>
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="open_device">
        <callback name="open_device">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be opened, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="acquire">
        <callback name="acquire">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be acquired, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to acquire</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <doc xml:space="preserve">the specs of the buffer</doc>
              <type name="AudioRingBufferSpec"
                    c:type="GstAudioRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="release">
        <callback name="release">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be released, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to release</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close_device">
        <callback name="close_device">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be closed, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be started, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to start</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pause">
        <callback name="pause">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be paused, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to pause</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resume">
        <callback name="resume">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be stopped, FALSE on error.

MT safe.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to stop</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of samples queued in the audio device.

MT safe.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to query</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the device could be activated in the requested mode,
FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to activate</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <doc xml:space="preserve">the new mode</doc>
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="commit">
        <callback name="commit">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The number of samples written to the ringbuffer or -1 on error. The
number of samples written can be less than @out_samples when @buf was interrupted
with a flush or stop.</doc>
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to commit</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
            <parameter name="sample" transfer-ownership="none">
              <doc xml:space="preserve">the sample position of the data</doc>
              <type name="guint64" c:type="guint64*"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <doc xml:space="preserve">the data to commit</doc>
              <array length="3" zero-terminated="0" c:type="guint8*">
                <type name="guint8" c:type="guint8"/>
              </array>
            </parameter>
            <parameter name="in_samples" transfer-ownership="none">
              <doc xml:space="preserve">the number of samples in the data to commit</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="out_samples" transfer-ownership="none">
              <doc xml:space="preserve">the number of samples to write to the ringbuffer</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="accum"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve">accumulator for rate conversion.</doc>
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_all">
        <callback name="clear_all">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="buf" transfer-ownership="none">
              <doc xml:space="preserve">the #GstAudioRingBuffer to clear</doc>
              <type name="AudioRingBuffer" c:type="GstAudioRingBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="AudioRingBufferFormatType"
                 glib:type-name="GstAudioRingBufferFormatType"
                 glib:get-type="gst_audio_ring_buffer_format_type_get_type"
                 c:type="GstAudioRingBufferFormatType">
      <doc xml:space="preserve">The format of the samples in the ringbuffer.</doc>
      <member name="raw"
              value="0"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW"
              glib:nick="raw">
        <doc xml:space="preserve">samples in linear or float</doc>
      </member>
      <member name="mu_law"
              value="1"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW"
              glib:nick="mu-law">
        <doc xml:space="preserve">samples in mulaw</doc>
      </member>
      <member name="a_law"
              value="2"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW"
              glib:nick="a-law">
        <doc xml:space="preserve">samples in alaw</doc>
      </member>
      <member name="ima_adpcm"
              value="3"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IMA_ADPCM"
              glib:nick="ima-adpcm">
        <doc xml:space="preserve">samples in ima adpcm</doc>
      </member>
      <member name="mpeg"
              value="4"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG"
              glib:nick="mpeg">
        <doc xml:space="preserve">samples in mpeg audio (but not AAC) format</doc>
      </member>
      <member name="gsm"
              value="5"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_GSM"
              glib:nick="gsm">
        <doc xml:space="preserve">samples in gsm format</doc>
      </member>
      <member name="iec958"
              value="6"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958"
              glib:nick="iec958">
        <doc xml:space="preserve">samples in IEC958 frames (e.g. AC3)</doc>
      </member>
      <member name="ac3"
              value="7"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3"
              glib:nick="ac3">
        <doc xml:space="preserve">samples in AC3 format</doc>
      </member>
      <member name="eac3"
              value="8"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3"
              glib:nick="eac3">
        <doc xml:space="preserve">samples in EAC3 format</doc>
      </member>
      <member name="dts"
              value="9"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS"
              glib:nick="dts">
        <doc xml:space="preserve">samples in DTS format</doc>
      </member>
      <member name="mpeg2_aac"
              value="10"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC"
              glib:nick="mpeg2-aac">
        <doc xml:space="preserve">samples in MPEG-2 AAC ADTS format</doc>
      </member>
      <member name="mpeg4_aac"
              value="11"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC"
              glib:nick="mpeg4-aac">
        <doc xml:space="preserve">samples in MPEG-4 AAC ADTS format</doc>
      </member>
      <member name="mpeg2_aac_raw"
              value="12"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW"
              glib:nick="mpeg2-aac-raw">
        <doc xml:space="preserve">samples in MPEG-2 AAC raw format (Since 1.12)</doc>
      </member>
      <member name="mpeg4_aac_raw"
              value="13"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW"
              glib:nick="mpeg4-aac-raw">
        <doc xml:space="preserve">samples in MPEG-4 AAC raw format (Since 1.12)</doc>
      </member>
      <member name="flac"
              value="14"
              c:identifier="GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC"
              glib:nick="flac">
        <doc xml:space="preserve">samples in FLAC format (Since 1.12)</doc>
      </member>
    </enumeration>
    <record name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec">
      <doc xml:space="preserve">The structure containing the format specification of the ringbuffer.</doc>
      <field name="caps" writable="1">
        <doc xml:space="preserve">The caps that generated the Spec.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </field>
      <field name="type" writable="1">
        <doc xml:space="preserve">the sample type</doc>
        <type name="AudioRingBufferFormatType"
              c:type="GstAudioRingBufferFormatType"/>
      </field>
      <field name="info" writable="1">
        <doc xml:space="preserve">the #GstAudioInfo</doc>
        <type name="AudioInfo" c:type="GstAudioInfo"/>
      </field>
      <field name="latency_time" writable="1">
        <doc xml:space="preserve">the latency in microseconds</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="buffer_time" writable="1">
        <doc xml:space="preserve">the total buffer size in microseconds</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="segsize" writable="1">
        <doc xml:space="preserve">the size of one segment in bytes</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="segtotal" writable="1">
        <doc xml:space="preserve">the total number of segments</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="seglatency" writable="1">
        <doc xml:space="preserve">number of segments queued in the lower level device,
 defaults to segtotal</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="AudioRingBufferState"
                 glib:type-name="GstAudioRingBufferState"
                 glib:get-type="gst_audio_ring_buffer_state_get_type"
                 c:type="GstAudioRingBufferState">
      <doc xml:space="preserve">The state of the ringbuffer.</doc>
      <member name="stopped"
              value="0"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_STOPPED"
              glib:nick="stopped">
        <doc xml:space="preserve">The ringbuffer is stopped</doc>
      </member>
      <member name="paused"
              value="1"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_PAUSED"
              glib:nick="paused">
        <doc xml:space="preserve">The ringbuffer is paused</doc>
      </member>
      <member name="started"
              value="2"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_STARTED"
              glib:nick="started">
        <doc xml:space="preserve">The ringbuffer is started</doc>
      </member>
      <member name="error"
              value="3"
              c:identifier="GST_AUDIO_RING_BUFFER_STATE_ERROR"
              glib:nick="error">
        <doc xml:space="preserve">The ringbuffer has encountered an
    error after it has been started, e.g. because the device was
    disconnected (Since 1.2)</doc>
      </member>
    </enumeration>
    <class name="AudioSink"
           c:symbol-prefix="audio_sink"
           c:type="GstAudioSink"
           parent="AudioBaseSink"
           glib:type-name="GstAudioSink"
           glib:get-type="gst_audio_sink_get_type"
           glib:type-struct="AudioSinkClass">
      <doc xml:space="preserve">This is the most simple base class for audio sinks that only requires
subclasses to implement a set of simple functions:

* `open()` :Open the device.

* `prepare()` :Configure the device with the specified format.

* `write()` :Write samples to the device.

* `reset()` :Unblock writes and flush the device.

* `delay()` :Get the number of samples written but not yet played
by the device.

* `unprepare()` :Undo operations done by prepare.

* `close()` :Close the device.

All scheduling of samples and timestamps is done in this base class
together with #GstAudioBaseSink using a default implementation of a
#GstAudioRingBuffer that uses threads.</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="write">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="AudioSink" c:type="GstAudioSink*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="element">
        <type name="AudioBaseSink" c:type="GstAudioBaseSink"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSinkClass"
            c:type="GstAudioSinkClass"
            glib:is-gtype-struct-for="AudioSink">
      <doc xml:space="preserve">#GstAudioSink class. Override the vmethods to implement functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class structure.</doc>
        <type name="AudioBaseSinkClass" c:type="GstAudioBaseSinkClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="AudioRingBufferSpec"
                    c:type="GstAudioRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="write">
        <callback name="write">
          <return-value transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="AudioSink" c:type="GstAudioSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AudioSrc"
           c:symbol-prefix="audio_src"
           c:type="GstAudioSrc"
           parent="AudioBaseSrc"
           glib:type-name="GstAudioSrc"
           glib:get-type="gst_audio_src_get_type"
           glib:type-struct="AudioSrcClass">
      <doc xml:space="preserve">This is the most simple base class for audio sources that only requires
subclasses to implement a set of simple functions:

* `open()` :Open the device.
* `prepare()` :Configure the device with the specified format.
* `read()` :Read samples from the device.
* `reset()` :Unblock reads and flush the device.
* `delay()` :Get the number of samples in the device but not yet read.
* `unprepare()` :Undo operations done by prepare.
* `close()` :Close the device.

All scheduling of samples and timestamps is done in this base class
together with #GstAudioBaseSrc using a default implementation of a
#GstAudioRingBuffer that uses threads.</doc>
      <virtual-method name="close">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="delay">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="open">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
          <parameter name="spec" transfer-ownership="none">
            <type name="AudioRingBufferSpec" c:type="GstAudioRingBufferSpec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="read">
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="reset">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unprepare">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="AudioSrc" c:type="GstAudioSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <field name="element">
        <type name="AudioBaseSrc" c:type="GstAudioBaseSrc"/>
      </field>
      <field name="thread" readable="0" private="1">
        <type name="GLib.Thread" c:type="GThread*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="AudioSrcClass"
            c:type="GstAudioSrcClass"
            glib:is-gtype-struct-for="AudioSrc">
      <doc xml:space="preserve">#GstAudioSrc class. Override the vmethod to implement
functionality.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the parent class.</doc>
        <type name="AudioBaseSrcClass" c:type="GstAudioBaseSrcClass"/>
      </field>
      <field name="open">
        <callback name="open">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="spec" transfer-ownership="none">
              <type name="AudioRingBufferSpec"
                    c:type="GstAudioRingBufferSpec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unprepare">
        <callback name="unprepare">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="close">
        <callback name="close">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="read">
        <callback name="read">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
            <parameter name="data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="timestamp" transfer-ownership="none">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="delay">
        <callback name="delay">
          <return-value transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="reset">
        <callback name="reset">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="AudioSrc" c:type="GstAudioSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AudioStreamAlign"
            c:type="GstAudioStreamAlign"
            version="1.14"
            glib:type-name="GstAudioStreamAlign"
            glib:get-type="gst_audio_stream_align_get_type"
            c:symbol-prefix="audio_stream_align">
      <doc xml:space="preserve">#GstAudioStreamAlign provides a helper object that helps tracking audio
stream alignment and discontinuities, and detects discontinuities if
possible.

See gst_audio_stream_align_new() for a description of its parameters and
gst_audio_stream_align_process() for the details of the processing.</doc>
      <constructor name="new"
                   c:identifier="gst_audio_stream_align_new"
                   version="1.14">
        <doc xml:space="preserve">Allocate a new #GstAudioStreamAlign with the given configuration. All
processing happens according to sample rate @rate, until
gst_audio_discont_wait_set_rate() is called with a new @rate.
A negative rate can be used for reverse playback.

@alignment_threshold gives the tolerance in nanoseconds after which a
timestamp difference is considered a discontinuity. Once detected,
@discont_wait nanoseconds have to pass without going below the threshold
again until the output buffer is marked as a discontinuity. These can later
be re-configured with gst_audio_stream_align_set_alignment_threshold() and
gst_audio_stream_align_set_discont_wait().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstAudioStreamAlign. free with gst_audio_stream_align_free().</doc>
          <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
        </return-value>
        <parameters>
          <parameter name="rate" transfer-ownership="none">
            <doc xml:space="preserve">a sample rate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="alignment_threshold" transfer-ownership="none">
            <doc xml:space="preserve">a alignment threshold in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="discont_wait" transfer-ownership="none">
            <doc xml:space="preserve">discont wait in nanoseconds</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="gst_audio_stream_align_copy"
              version="1.14">
        <doc xml:space="preserve">Copy a GstAudioStreamAlign structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GstAudioStreamAlign. free with gst_audio_stream_align_free.</doc>
          <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioStreamAlign</doc>
            <type name="AudioStreamAlign" c:type="const GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="gst_audio_stream_align_free"
              version="1.14">
        <doc xml:space="preserve">Free a GstAudioStreamAlign structure previously allocated with gst_audio_stream_align_new()
or gst_audio_stream_align_copy().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioStreamAlign</doc>
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alignment_threshold"
              c:identifier="gst_audio_stream_align_get_alignment_threshold">
        <return-value transfer-ownership="none">
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_discont_wait"
              c:identifier="gst_audio_stream_align_get_discont_wait">
        <return-value transfer-ownership="none">
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rate" c:identifier="gst_audio_stream_align_get_rate">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_samples_since_discont"
              c:identifier="gst_audio_stream_align_get_samples_since_discont"
              version="1.14">
        <doc xml:space="preserve">Returns the number of samples that were processed since the last
discontinuity was detected.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of samples processed since the last discontinuity.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioStreamAlign</doc>
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_timestamp_at_discont"
              c:identifier="gst_audio_stream_align_get_timestamp_at_discont"
              version="1.14">
        <doc xml:space="preserve">Timestamp that was passed when a discontinuity was detected, i.e. the first
timestamp after the discontinuity.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The last timestamp at when a discontinuity was detected</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioStreamAlign</doc>
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="mark_discont"
              c:identifier="gst_audio_stream_align_mark_discont"
              version="1.14">
        <doc xml:space="preserve">Marks the next buffer as discontinuous and resets timestamp tracking.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioStreamAlign</doc>
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="process"
              c:identifier="gst_audio_stream_align_process"
              version="1.14">
        <doc xml:space="preserve">Processes data with @timestamp and @n_samples, and returns the output
timestamp, duration and sample position together with a boolean to signal
whether a discontinuity was detected or not. All non-discontinuous data
will have perfect timestamps and durations.

A discontinuity is detected once the difference between the actual
timestamp and the timestamp calculated from the sample count since the last
discontinuity differs by more than the alignment threshold for a duration
longer than discont wait.

Note: In reverse playback, every buffer is considered discontinuous in the
context of buffer flags because the last sample of the previous buffer is
discontinuous with the first sample of the current one. However for this
function they are only considered discontinuous in reverse playback if the
first sample of the previous buffer is discontinuous with the last sample
of the current one.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a discontinuity was detected, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <doc xml:space="preserve">a #GstAudioStreamAlign</doc>
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
          <parameter name="discont" transfer-ownership="none">
            <doc xml:space="preserve">if this data is considered to be discontinuous</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:space="preserve">a #GstClockTime of the start of the data</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="n_samples" transfer-ownership="none">
            <doc xml:space="preserve">number of samples to process</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="out_timestamp"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">output timestamp of the data</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="out_duration"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">output duration of the data</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="out_sample_position"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">output sample position of the start of the data</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alignment_threshold"
              c:identifier="gst_audio_stream_align_set_alignment_threshold">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
          <parameter name="alignment_threshold" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_discont_wait"
              c:identifier="gst_audio_stream_align_set_discont_wait">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
          <parameter name="discont_wait" transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rate" c:identifier="gst_audio_stream_align_set_rate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="align" transfer-ownership="none">
            <type name="AudioStreamAlign" c:type="GstAudioStreamAlign*"/>
          </instance-parameter>
          <parameter name="rate" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <constant name="META_TAG_AUDIO_CHANNELS_STR"
              value="channels"
              c:type="GST_META_TAG_AUDIO_CHANNELS_STR"
              version="1.2">
      <doc xml:space="preserve">This metadata stays relevant as long as channels are unchanged.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_TAG_AUDIO_RATE_STR"
              value="rate"
              c:type="GST_META_TAG_AUDIO_RATE_STR"
              version="1.8">
      <doc xml:space="preserve">This metadata stays relevant as long as sample rate is unchanged.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="META_TAG_AUDIO_STR"
              value="audio"
              c:type="GST_META_TAG_AUDIO_STR"
              version="1.2">
      <doc xml:space="preserve">This metadata is relevant for audio streams.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="StreamVolume"
               c:symbol-prefix="stream_volume"
               c:type="GstStreamVolume"
               glib:type-name="GstStreamVolume"
               glib:get-type="gst_stream_volume_get_type"
               glib:type-struct="StreamVolumeInterface">
      <doc xml:space="preserve">This interface is implemented by elements that provide a stream volume. Examples for
such elements are #volume and #playbin.

Applications can use this interface to get or set the current stream volume. For this
the "volume" #GObject property can be used or the helper functions gst_stream_volume_set_volume()
and gst_stream_volume_get_volume(). This volume is always a linear factor, i.e. 0.0 is muted
1.0 is 100%. For showing the volume in a GUI it might make sense to convert it to
a different format by using gst_stream_volume_convert_volume(). Volume sliders should usually
use a cubic volume.

Separate from the volume the stream can also be muted by the "mute" #GObject property or
gst_stream_volume_set_mute() and gst_stream_volume_get_mute().

Elements that provide some kind of stream volume should implement the "volume" and
"mute" #GObject properties and handle setting and getting of them properly.
The volume property is defined to be a linear volume factor.</doc>
      <function name="convert_volume"
                c:identifier="gst_stream_volume_convert_volume">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the converted volume</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <parameter name="from" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat to convert from</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
          <parameter name="to" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat to convert to</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">Volume in @from format that should be converted</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_mute" c:identifier="gst_stream_volume_get_mute">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Returns %TRUE if the stream is muted</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_volume" c:identifier="gst_stream_volume_get_volume">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The current stream volume as linear factor</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat which should be returned</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mute" c:identifier="gst_stream_volume_set_mute">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
          <parameter name="mute" transfer-ownership="none">
            <doc xml:space="preserve">Mute state that should be set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_volume" c:identifier="gst_stream_volume_set_volume">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolume that should be used</doc>
            <type name="StreamVolume" c:type="GstStreamVolume*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">#GstStreamVolumeFormat of @val</doc>
            <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
          </parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve">Linear volume factor that should be set</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="mute" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="volume" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
    </interface>
    <enumeration name="StreamVolumeFormat" c:type="GstStreamVolumeFormat">
      <doc xml:space="preserve">Different representations of a stream volume. gst_stream_volume_convert_volume()
allows to convert between the different representations.

Formulas to convert from a linear to a cubic or dB volume are
cbrt(val) and 20 * log10 (val).</doc>
      <member name="linear"
              value="0"
              c:identifier="GST_STREAM_VOLUME_FORMAT_LINEAR">
        <doc xml:space="preserve">Linear scale factor, 1.0 = 100%</doc>
      </member>
      <member name="cubic"
              value="1"
              c:identifier="GST_STREAM_VOLUME_FORMAT_CUBIC">
        <doc xml:space="preserve">Cubic volume scale</doc>
      </member>
      <member name="db" value="2" c:identifier="GST_STREAM_VOLUME_FORMAT_DB">
        <doc xml:space="preserve">Logarithmic volume scale (dB, amplitude not power)</doc>
      </member>
    </enumeration>
    <record name="StreamVolumeInterface"
            c:type="GstStreamVolumeInterface"
            glib:is-gtype-struct-for="StreamVolume">
      <field name="iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
    </record>
    <function name="audio_buffer_clip" c:identifier="gst_audio_buffer_clip">
      <doc xml:space="preserve">Clip the buffer to the given %GstSegment.

After calling this function the caller does not own a reference to
@buffer anymore.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">%NULL if the buffer is completely outside the configured segment,
otherwise the clipped buffer is returned.

If the buffer has no timestamp, it is assumed to be inside the segment and
is not clipped</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="full">
          <doc xml:space="preserve">The buffer to clip.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="segment" transfer-ownership="none">
          <doc xml:space="preserve">Segment in %GST_FORMAT_TIME or %GST_FORMAT_DEFAULT to which
          the buffer should be clipped.</doc>
          <type name="Gst.Segment" c:type="const GstSegment*"/>
        </parameter>
        <parameter name="rate" transfer-ownership="none">
          <doc xml:space="preserve">sample rate.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="bpf" transfer-ownership="none">
          <doc xml:space="preserve">size of one audio frame in bytes. This is the size of one sample *
number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_buffer_reorder_channels"
              c:identifier="gst_audio_buffer_reorder_channels">
      <doc xml:space="preserve">Reorders @buffer from the channel positions @from to the channel
positions @to. @from and @to must contain the same number of
positions and the same positions, only in a different order.
@buffer must be writable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reordering was possible.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">The buffer to reorder.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioFormat of the buffer.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions in the buffer.</doc>
          <array length="2"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to convert to.</doc>
          <array length="2"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_get_fallback_mask"
              c:identifier="gst_audio_channel_get_fallback_mask"
              version="1.8">
      <doc xml:space="preserve">Get the fallback channel-mask for the given number of channels.

This function returns a reasonable fallback channel-mask and should be
called as a last resort when the specific channel map is unknown.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a fallback channel-mask for @channels or 0 when there is no
mask and mono.</doc>
        <type name="guint64" c:type="guint64"/>
      </return-value>
      <parameters>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">the number of channels</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_mixer_new"
              c:identifier="gst_audio_channel_mixer_new"
              moved-to="AudioChannelMixer.new"
              introspectable="0">
      <doc xml:space="preserve">Create a new channel mixer object for the given parameters.</doc>
      <return-value>
        <doc xml:space="preserve">a new #GstAudioChannelMixer object, or %NULL if @format isn't supported.
  Free with gst_audio_channel_mixer_free() after usage.</doc>
        <type name="AudioChannelMixer" c:type="GstAudioChannelMixer*"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">#GstAudioChannelMixerFlags</doc>
          <type name="AudioChannelMixerFlags"
                c:type="GstAudioChannelMixerFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="in_channels" transfer-ownership="none">
          <doc xml:space="preserve">number of input channels</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="in_position" transfer-ownership="none">
          <doc xml:space="preserve">positions of input channels</doc>
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
        </parameter>
        <parameter name="out_channels" transfer-ownership="none">
          <doc xml:space="preserve">number of output channels</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="out_position" transfer-ownership="none">
          <doc xml:space="preserve">positions of output channels</doc>
          <type name="AudioChannelPosition" c:type="GstAudioChannelPosition*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_mixer_new_with_matrix"
              c:identifier="gst_audio_channel_mixer_new_with_matrix"
              moved-to="AudioChannelMixer.new_with_matrix"
              version="1.14"
              introspectable="0">
      <doc xml:space="preserve">Create a new channel mixer object for the given parameters.</doc>
      <return-value>
        <doc xml:space="preserve">a new #GstAudioChannelMixer object, or %NULL if @format isn't supported,
  @matrix is invalid, or @matrix is %NULL and @in_channels != @out_channels.
  Free with gst_audio_channel_mixer_free() after usage.</doc>
        <type name="AudioChannelMixer" c:type="GstAudioChannelMixer*"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">#GstAudioChannelMixerFlags</doc>
          <type name="AudioChannelMixerFlags"
                c:type="GstAudioChannelMixerFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="in_channels" transfer-ownership="none">
          <doc xml:space="preserve">number of input channels</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="out_channels" transfer-ownership="none">
          <doc xml:space="preserve">number of output channels</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="matrix"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">channel conversion matrix, m[@in_channels][@out_channels].
  If identity matrix, passthrough applies. If %NULL, a (potentially truncated)
  identity matrix is generated.</doc>
          <type name="gfloat" c:type="gfloat**"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_positions_from_mask"
              c:identifier="gst_audio_channel_positions_from_mask">
      <doc xml:space="preserve">Convert the @channels present in @channel_mask to a @position array
(which should have at least @channels entries ensured by caller).
If @channel_mask is set to 0, it is considered as 'not present' for purpose
of conversion.
A partially valid @channel_mask with less bits set than the number
of channels is considered valid.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if channel and channel mask are valid and could be converted</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="channel_mask" transfer-ownership="none">
          <doc xml:space="preserve">The input channel_mask</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The
  %GstAudioChannelPosition&lt;!-- --&gt;s</doc>
          <array length="0"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_positions_to_mask"
              c:identifier="gst_audio_channel_positions_to_mask">
      <doc xml:space="preserve">Convert the @position array of @channels channels to a bitmask.

If @force_order is %TRUE it additionally checks if the channels are
in the order required by GStreamer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid and could be converted.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioChannelPositions</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="force_order" transfer-ownership="none">
          <doc xml:space="preserve">Only consider the GStreamer channel order.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="channel_mask"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">the output channel mask</doc>
          <type name="guint64" c:type="guint64*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_positions_to_string"
              c:identifier="gst_audio_channel_positions_to_string">
      <doc xml:space="preserve">Converts @position to a human-readable string representation for
debugging purposes.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly allocated string representing
@position

Since 1.10</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioChannelPositions
  to convert.</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_channel_positions_to_valid_order"
              c:identifier="gst_audio_channel_positions_to_valid_order">
      <doc xml:space="preserve">Reorders the channel positions in @position from any order to
the GStreamer channel order.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid and reordering
was successful.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to
  reorder to.</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_check_valid_channel_positions"
              c:identifier="gst_audio_check_valid_channel_positions">
      <doc xml:space="preserve">Checks if @position contains valid channel positions for
@channels channels. If @force_order is %TRUE it additionally
checks if the channels are in the order required by GStreamer.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="position" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioChannelPositions
  to check.</doc>
          <array length="1"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="force_order" transfer-ownership="none">
          <doc xml:space="preserve">Only consider the GStreamer channel order.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_clipping_meta_api_get_type"
              c:identifier="gst_audio_clipping_meta_api_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="audio_clipping_meta_get_info"
              c:identifier="gst_audio_clipping_meta_get_info"
              moved-to="AudioClippingMeta.get_info">
      <return-value transfer-ownership="none">
        <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
      </return-value>
    </function>
    <function name="audio_downmix_meta_api_get_type"
              c:identifier="gst_audio_downmix_meta_api_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="audio_downmix_meta_get_info"
              c:identifier="gst_audio_downmix_meta_get_info"
              moved-to="AudioDownmixMeta.get_info">
      <return-value transfer-ownership="none">
        <type name="Gst.MetaInfo" c:type="const GstMetaInfo*"/>
      </return-value>
    </function>
    <function name="audio_format_build_integer"
              c:identifier="gst_audio_format_build_integer"
              moved-to="AudioFormat.build_integer">
      <doc xml:space="preserve">Construct a #GstAudioFormat with given parameters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GstAudioFormat or GST_AUDIO_FORMAT_UNKNOWN when no audio format
exists with the given parameters.</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </return-value>
      <parameters>
        <parameter name="sign" transfer-ownership="none">
          <doc xml:space="preserve">signed or unsigned format</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="endianness" transfer-ownership="none">
          <doc xml:space="preserve">G_LITTLE_ENDIAN or G_BIG_ENDIAN</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve">amount of bits used per sample</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="depth" transfer-ownership="none">
          <doc xml:space="preserve">amount of used bits in @width</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_fill_silence"
              c:identifier="gst_audio_format_fill_silence"
              moved-to="AudioFormat.fill_silence">
      <doc xml:space="preserve">Fill @length bytes in @dest with silence samples for @info.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormatInfo</doc>
          <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
        </parameter>
        <parameter name="dest" transfer-ownership="none">
          <doc xml:space="preserve">a destination
  to fill</doc>
          <array length="2" zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve">the length to fill</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_from_string"
              c:identifier="gst_audio_format_from_string"
              moved-to="AudioFormat.from_string">
      <doc xml:space="preserve">Convert the @format string to its #GstAudioFormat.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstAudioFormat for @format or GST_AUDIO_FORMAT_UNKNOWN when the
string is not a known format.</doc>
        <type name="AudioFormat" c:type="GstAudioFormat"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a format string</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_get_info"
              c:identifier="gst_audio_format_get_info"
              moved-to="AudioFormat.get_info">
      <doc xml:space="preserve">Get the #GstAudioFormatInfo for @format</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The #GstAudioFormatInfo for @format.</doc>
        <type name="AudioFormatInfo" c:type="const GstAudioFormatInfo*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioFormat</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_format_info_get_type"
              c:identifier="gst_audio_format_info_get_type">
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="audio_format_to_string"
              c:identifier="gst_audio_format_to_string"
              moved-to="AudioFormat.to_string">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_get_channel_reorder_map"
              c:identifier="gst_audio_get_channel_reorder_map">
      <doc xml:space="preserve">Returns a reorder map for @from to @to that can be used in
custom channel reordering code, e.g. to convert from or to the
GStreamer channel order. @from and @to must contain the same
number of positions and the same positions, only in a
different order.

The resulting @reorder_map can be used for reordering by assigning
channel i of the input to channel reorder_map[i] of the output.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the channel positions are valid and reordering
is possible.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to reorder from.</doc>
          <array length="0"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to reorder to.</doc>
          <array length="0"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="reorder_map" transfer-ownership="none">
          <doc xml:space="preserve">Pointer to the reorder map.</doc>
          <array length="0" zero-terminated="0" c:type="gint*">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_iec61937_frame_size"
              c:identifier="gst_audio_iec61937_frame_size">
      <doc xml:space="preserve">Calculated the size of the buffer expected by gst_audio_iec61937_payload() for
payloading type from @spec.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the size or 0 if the given @type is not supported or cannot be
payloaded.</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="spec" transfer-ownership="none">
          <doc xml:space="preserve">the ringbufer spec</doc>
          <type name="AudioRingBufferSpec"
                c:type="const GstAudioRingBufferSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_iec61937_payload"
              c:identifier="gst_audio_iec61937_payload">
      <doc xml:space="preserve">Payloads @src in the form specified by IEC 61937 for the type from @spec and
stores the result in @dst. @src must contain exactly one frame of data and
the frame is not checked for errors.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">transfer-full: %TRUE if the payloading was successful, %FALSE
otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve">a buffer containing the data to payload</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="src_n" transfer-ownership="none">
          <doc xml:space="preserve">size of @src in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:space="preserve">the destination buffer to store the
      payloaded contents in. Should not overlap with @src</doc>
          <array length="3" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="dst_n" transfer-ownership="none">
          <doc xml:space="preserve">size of @dst in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="spec" transfer-ownership="none">
          <doc xml:space="preserve">the ringbufer spec for @src</doc>
          <type name="AudioRingBufferSpec"
                c:type="const GstAudioRingBufferSpec*"/>
        </parameter>
        <parameter name="endianness" transfer-ownership="none">
          <doc xml:space="preserve">the expected byte order of the payloaded data</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_quantize_new"
              c:identifier="gst_audio_quantize_new"
              moved-to="AudioQuantize.new"
              introspectable="0">
      <doc xml:space="preserve">Create a new quantizer object with the given parameters.

Output samples will be quantized to a multiple of @quantizer. Better
performance is achieved when @quantizer is a power of 2.

Dithering and noise-shaping can be performed during quantization with
the @dither and @ns parameters.</doc>
      <return-value>
        <doc xml:space="preserve">a new #GstAudioQuantize. Free with gst_audio_quantize_free().</doc>
        <type name="AudioQuantize" c:type="GstAudioQuantize*"/>
      </return-value>
      <parameters>
        <parameter name="dither" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioDitherMethod</doc>
          <type name="AudioDitherMethod" c:type="GstAudioDitherMethod"/>
        </parameter>
        <parameter name="ns" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioNoiseShapingMethod</doc>
          <type name="AudioNoiseShapingMethod"
                c:type="GstAudioNoiseShapingMethod"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">#GstAudioQuantizeFlags</doc>
          <type name="AudioQuantizeFlags" c:type="GstAudioQuantizeFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">the #GstAudioFormat of the samples</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">the amount of channels in the samples</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="quantizer" transfer-ownership="none">
          <doc xml:space="preserve">the quantizer to use</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_reorder_channels"
              c:identifier="gst_audio_reorder_channels">
      <doc xml:space="preserve">Reorders @data from the channel positions @from to the channel
positions @to. @from and @to must contain the same number of
positions and the same positions, only in a different order.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the reordering was possible.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve">The pointer to
  the memory.</doc>
          <array length="1" zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">The size of the memory.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">The %GstAudioFormat of the buffer.</doc>
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions in the buffer.</doc>
          <array length="3"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">The channel positions to convert to.</doc>
          <array length="3"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="audio_resampler_new"
              c:identifier="gst_audio_resampler_new"
              moved-to="AudioResampler.new">
      <doc xml:space="preserve">Make a new resampler.</doc>
      <return-value transfer-ownership="full" skip="1">
        <doc xml:space="preserve">%TRUE on success</doc>
        <type name="AudioResampler" c:type="GstAudioResampler*"/>
      </return-value>
      <parameters>
        <parameter name="method" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioResamplerMethod</doc>
          <type name="AudioResamplerMethod" c:type="GstAudioResamplerMethod"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">#GstAudioResamplerFlags</doc>
          <type name="AudioResamplerFlags" c:type="GstAudioResamplerFlags"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="AudioFormat" c:type="GstAudioFormat"/>
        </parameter>
        <parameter name="channels" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="in_rate" transfer-ownership="none">
          <doc xml:space="preserve">input rate</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="out_rate" transfer-ownership="none">
          <doc xml:space="preserve">output rate</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="options" transfer-ownership="none">
          <doc xml:space="preserve">extra options</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="audio_resampler_options_set_quality"
              c:identifier="gst_audio_resampler_options_set_quality"
              moved-to="AudioResampler.options_set_quality">
      <doc xml:space="preserve">Set the parameters for resampling from @in_rate to @out_rate using @method
for @quality in @options.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="method" transfer-ownership="none">
          <doc xml:space="preserve">a #GstAudioResamplerMethod</doc>
          <type name="AudioResamplerMethod" c:type="GstAudioResamplerMethod"/>
        </parameter>
        <parameter name="quality" transfer-ownership="none">
          <doc xml:space="preserve">the quality</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="in_rate" transfer-ownership="none">
          <doc xml:space="preserve">the input rate</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="out_rate" transfer-ownership="none">
          <doc xml:space="preserve">the output rate</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="options" transfer-ownership="none">
          <doc xml:space="preserve">a #GstStructure</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_add_audio_clipping_meta"
              c:identifier="gst_buffer_add_audio_clipping_meta"
              version="1.8">
      <doc xml:space="preserve">Attaches #GstAudioClippingMeta metadata to @buffer with the given parameters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstAudioClippingMeta on @buffer.</doc>
        <type name="AudioClippingMeta" c:type="GstAudioClippingMeta*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">GstFormat of @start and @stop, GST_FORMAT_DEFAULT is samples</doc>
          <type name="Gst.Format" c:type="GstFormat"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">Amount of audio to clip from start of buffer</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">Amount of  to clip from end of buffer</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_add_audio_downmix_meta"
              c:identifier="gst_buffer_add_audio_downmix_meta">
      <doc xml:space="preserve">Attaches #GstAudioDownmixMeta metadata to @buffer with the given parameters.

@matrix is an two-dimensional array of @to_channels times @from_channels
coefficients, i.e. the i-th output channels is constructed by multiplicating
the input channels with the coefficients in @matrix[i] and taking the sum
of the results.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstAudioDownmixMeta on @buffer.</doc>
        <type name="AudioDownmixMeta" c:type="GstAudioDownmixMeta*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="from_position" transfer-ownership="none">
          <doc xml:space="preserve">the channel positions
  of the source</doc>
          <array length="2"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="from_channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels of the source</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="to_position" transfer-ownership="none">
          <doc xml:space="preserve">the channel positions of
  the destination</doc>
          <array length="4"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to_channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels of the destination</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve">The matrix coefficients.</doc>
          <type name="gfloat" c:type="const gfloat**"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_audio_downmix_meta_for_channels"
              c:identifier="gst_buffer_get_audio_downmix_meta_for_channels">
      <doc xml:space="preserve">Find the #GstAudioDownmixMeta on @buffer for the given destination
channel positions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GstAudioDownmixMeta on @buffer.</doc>
        <type name="AudioDownmixMeta" c:type="GstAudioDownmixMeta*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">a #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="to_position" transfer-ownership="none">
          <doc xml:space="preserve">the channel positions of
  the destination</doc>
          <array length="2"
                 zero-terminated="0"
                 c:type="GstAudioChannelPosition*">
            <type name="AudioChannelPosition"
                  c:type="GstAudioChannelPosition"/>
          </array>
        </parameter>
        <parameter name="to_channels" transfer-ownership="none">
          <doc xml:space="preserve">The number of channels of the destination</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="stream_volume_convert_volume"
              c:identifier="gst_stream_volume_convert_volume"
              moved-to="StreamVolume.convert_volume">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the converted volume</doc>
        <type name="gdouble" c:type="gdouble"/>
      </return-value>
      <parameters>
        <parameter name="from" transfer-ownership="none">
          <doc xml:space="preserve">#GstStreamVolumeFormat to convert from</doc>
          <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
        </parameter>
        <parameter name="to" transfer-ownership="none">
          <doc xml:space="preserve">#GstStreamVolumeFormat to convert to</doc>
          <type name="StreamVolumeFormat" c:type="GstStreamVolumeFormat"/>
        </parameter>
        <parameter name="val" transfer-ownership="none">
          <doc xml:space="preserve">Volume in @from format that should be converted</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
