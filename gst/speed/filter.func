/* -*- Mode: c; c-basic-offset: 2 -*- */ 
    _FORMAT *in_data, *out_data;
    static gint64 offset = 0, timestamp = 0;

    /* get a buffer here so that we can have something to interpolate
     * against for the first few samples if speed < 0.5 */
    in_data = (_FORMAT*) GST_BUFFER_DATA(in);
    nin = GST_BUFFER_SIZE(in)/sizeof(_FORMAT);
    lower = in_data[0];
    i_float = 0.5 * (speed - 1.0);
    i = i_float + 1.0; /* ciel(i_float) for ints */
    
    do {
      speed = filter->speed; /* update this, it might have changed */
      
      out = gst_buffer_new();
      GST_BUFFER_DATA(out) = (gchar*) g_new(_FORMAT,SPEED_BUFSIZE/sizeof(_FORMAT));
      GST_BUFFER_SIZE(out) = SPEED_BUFSIZE;
      out_data = (_FORMAT*) GST_BUFFER_DATA(out);
      nout = GST_BUFFER_SIZE(out) / sizeof(_FORMAT);
      GST_BUFFER_TIMESTAMP (out) = timestamp;
      offset += nout;
      timestamp = offset * GST_SECOND / filter->rate;
      
      for (j=0; j<nout; j++) {
        /* index of upper bounds of interpolation for
         * new sample, got it by trial&error on the chalkboard */
        i_float += speed;
        i = i_float + 1.0; /* ciel(i_float) for ints */
        
        while (i >= nin) {
          i = i % nin;
          i_float = i_float - nin;
          lower = in_data[nin-1];
          gst_buffer_unref(in);
          in = GST_BUFFER (gst_pad_pull (filter->sinkpad));
          
          while (GST_IS_EVENT (in)) {
            gst_pad_event_default (filter->srcpad, GST_EVENT (in));
            in = GST_BUFFER (gst_pad_pull (filter->sinkpad));
          }
          
          in_data = (_FORMAT*) GST_BUFFER_DATA(in);
          nin = GST_BUFFER_SIZE(in) / sizeof(_FORMAT);
        } 
        
        if (i>0)
          lower = in_data[i-1];
        
        interp = i_float - floor(i_float);
        
        out_data[j] = lower*(1-interp) + in_data[i]*interp;
        
        lower = in_data[i];
      }
      
      gst_pad_push(filter->srcpad, GST_DATA (out));

      gst_element_yield (element);
    } while (TRUE);
